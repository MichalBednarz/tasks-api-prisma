/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      Project: ProjectObject
      Subproject: SubprojectObject
      Task: TaskObject
      Timelog: TimelogObject
      Tag: TagObject
      ProjectConnection: ProjectConnectionObject
      PageInfo: PageInfoObject
      ProjectEdge: ProjectEdgeObject
      AggregateProject: AggregateProjectObject
      SubprojectConnection: SubprojectConnectionObject
      SubprojectEdge: SubprojectEdgeObject
      AggregateSubproject: AggregateSubprojectObject
      TaskConnection: TaskConnectionObject
      TaskEdge: TaskEdgeObject
      AggregateTask: AggregateTaskObject
      TimelogConnection: TimelogConnectionObject
      TimelogEdge: TimelogEdgeObject
      AggregateTimelog: AggregateTimelogObject
      TagConnection: TagConnectionObject
      TagEdge: TagEdgeObject
      AggregateTag: AggregateTagObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      ProjectSubscriptionPayload: ProjectSubscriptionPayloadObject
      ProjectPreviousValues: ProjectPreviousValuesObject
      SubprojectSubscriptionPayload: SubprojectSubscriptionPayloadObject
      SubprojectPreviousValues: SubprojectPreviousValuesObject
      TaskSubscriptionPayload: TaskSubscriptionPayloadObject
      TaskPreviousValues: TaskPreviousValuesObject
      TimelogSubscriptionPayload: TimelogSubscriptionPayloadObject
      TimelogPreviousValues: TimelogPreviousValuesObject
      TagSubscriptionPayload: TagSubscriptionPayloadObject
      TagPreviousValues: TagPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      Project: ProjectFieldDetails
      Subproject: SubprojectFieldDetails
      Task: TaskFieldDetails
      Timelog: TimelogFieldDetails
      Tag: TagFieldDetails
      ProjectConnection: ProjectConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      ProjectEdge: ProjectEdgeFieldDetails
      AggregateProject: AggregateProjectFieldDetails
      SubprojectConnection: SubprojectConnectionFieldDetails
      SubprojectEdge: SubprojectEdgeFieldDetails
      AggregateSubproject: AggregateSubprojectFieldDetails
      TaskConnection: TaskConnectionFieldDetails
      TaskEdge: TaskEdgeFieldDetails
      AggregateTask: AggregateTaskFieldDetails
      TimelogConnection: TimelogConnectionFieldDetails
      TimelogEdge: TimelogEdgeFieldDetails
      AggregateTimelog: AggregateTimelogFieldDetails
      TagConnection: TagConnectionFieldDetails
      TagEdge: TagEdgeFieldDetails
      AggregateTag: AggregateTagFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      ProjectSubscriptionPayload: ProjectSubscriptionPayloadFieldDetails
      ProjectPreviousValues: ProjectPreviousValuesFieldDetails
      SubprojectSubscriptionPayload: SubprojectSubscriptionPayloadFieldDetails
      SubprojectPreviousValues: SubprojectPreviousValuesFieldDetails
      TaskSubscriptionPayload: TaskSubscriptionPayloadFieldDetails
      TaskPreviousValues: TaskPreviousValuesFieldDetails
      TimelogSubscriptionPayload: TimelogSubscriptionPayloadFieldDetails
      TimelogPreviousValues: TimelogPreviousValuesFieldDetails
      TagSubscriptionPayload: TagSubscriptionPayloadFieldDetails
      TagPreviousValues: TagPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      ProjectWhereUniqueInput: ProjectWhereUniqueInputInputObject
      SubprojectWhereInput: SubprojectWhereInputInputObject
      ProjectWhereInput: ProjectWhereInputInputObject
      TaskWhereInput: TaskWhereInputInputObject
      TimelogWhereInput: TimelogWhereInputInputObject
      TagWhereInput: TagWhereInputInputObject
      SubprojectWhereUniqueInput: SubprojectWhereUniqueInputInputObject
      TaskWhereUniqueInput: TaskWhereUniqueInputInputObject
      TimelogWhereUniqueInput: TimelogWhereUniqueInputInputObject
      TagWhereUniqueInput: TagWhereUniqueInputInputObject
      ProjectCreateInput: ProjectCreateInputInputObject
      SubprojectCreateManyWithoutProjectInput: SubprojectCreateManyWithoutProjectInputInputObject
      SubprojectCreateWithoutProjectInput: SubprojectCreateWithoutProjectInputInputObject
      TaskCreateManyWithoutSubprojectInput: TaskCreateManyWithoutSubprojectInputInputObject
      TaskCreateWithoutSubprojectInput: TaskCreateWithoutSubprojectInputInputObject
      TimelogCreateManyWithoutTaskInput: TimelogCreateManyWithoutTaskInputInputObject
      TimelogCreateWithoutTaskInput: TimelogCreateWithoutTaskInputInputObject
      TagCreateManyWithoutTasksInput: TagCreateManyWithoutTasksInputInputObject
      TagCreateWithoutTasksInput: TagCreateWithoutTasksInputInputObject
      ProjectUpdateInput: ProjectUpdateInputInputObject
      SubprojectUpdateManyWithoutProjectInput: SubprojectUpdateManyWithoutProjectInputInputObject
      SubprojectUpdateWithWhereUniqueWithoutProjectInput: SubprojectUpdateWithWhereUniqueWithoutProjectInputInputObject
      SubprojectUpdateWithoutProjectDataInput: SubprojectUpdateWithoutProjectDataInputInputObject
      TaskUpdateManyWithoutSubprojectInput: TaskUpdateManyWithoutSubprojectInputInputObject
      TaskUpdateWithWhereUniqueWithoutSubprojectInput: TaskUpdateWithWhereUniqueWithoutSubprojectInputInputObject
      TaskUpdateWithoutSubprojectDataInput: TaskUpdateWithoutSubprojectDataInputInputObject
      TimelogUpdateManyWithoutTaskInput: TimelogUpdateManyWithoutTaskInputInputObject
      TimelogUpdateWithWhereUniqueWithoutTaskInput: TimelogUpdateWithWhereUniqueWithoutTaskInputInputObject
      TimelogUpdateWithoutTaskDataInput: TimelogUpdateWithoutTaskDataInputInputObject
      TimelogUpsertWithWhereUniqueWithoutTaskInput: TimelogUpsertWithWhereUniqueWithoutTaskInputInputObject
      TimelogScalarWhereInput: TimelogScalarWhereInputInputObject
      TimelogUpdateManyWithWhereNestedInput: TimelogUpdateManyWithWhereNestedInputInputObject
      TimelogUpdateManyDataInput: TimelogUpdateManyDataInputInputObject
      TagUpdateManyWithoutTasksInput: TagUpdateManyWithoutTasksInputInputObject
      TagUpdateWithWhereUniqueWithoutTasksInput: TagUpdateWithWhereUniqueWithoutTasksInputInputObject
      TagUpdateWithoutTasksDataInput: TagUpdateWithoutTasksDataInputInputObject
      TagUpsertWithWhereUniqueWithoutTasksInput: TagUpsertWithWhereUniqueWithoutTasksInputInputObject
      TagScalarWhereInput: TagScalarWhereInputInputObject
      TagUpdateManyWithWhereNestedInput: TagUpdateManyWithWhereNestedInputInputObject
      TagUpdateManyDataInput: TagUpdateManyDataInputInputObject
      TaskUpsertWithWhereUniqueWithoutSubprojectInput: TaskUpsertWithWhereUniqueWithoutSubprojectInputInputObject
      TaskScalarWhereInput: TaskScalarWhereInputInputObject
      TaskUpdateManyWithWhereNestedInput: TaskUpdateManyWithWhereNestedInputInputObject
      TaskUpdateManyDataInput: TaskUpdateManyDataInputInputObject
      SubprojectUpsertWithWhereUniqueWithoutProjectInput: SubprojectUpsertWithWhereUniqueWithoutProjectInputInputObject
      SubprojectScalarWhereInput: SubprojectScalarWhereInputInputObject
      SubprojectUpdateManyWithWhereNestedInput: SubprojectUpdateManyWithWhereNestedInputInputObject
      SubprojectUpdateManyDataInput: SubprojectUpdateManyDataInputInputObject
      ProjectUpdateManyMutationInput: ProjectUpdateManyMutationInputInputObject
      SubprojectCreateInput: SubprojectCreateInputInputObject
      ProjectCreateOneWithoutSubprojectsInput: ProjectCreateOneWithoutSubprojectsInputInputObject
      ProjectCreateWithoutSubprojectsInput: ProjectCreateWithoutSubprojectsInputInputObject
      SubprojectUpdateInput: SubprojectUpdateInputInputObject
      ProjectUpdateOneRequiredWithoutSubprojectsInput: ProjectUpdateOneRequiredWithoutSubprojectsInputInputObject
      ProjectUpdateWithoutSubprojectsDataInput: ProjectUpdateWithoutSubprojectsDataInputInputObject
      ProjectUpsertWithoutSubprojectsInput: ProjectUpsertWithoutSubprojectsInputInputObject
      SubprojectUpdateManyMutationInput: SubprojectUpdateManyMutationInputInputObject
      TaskCreateInput: TaskCreateInputInputObject
      SubprojectCreateOneWithoutTasksInput: SubprojectCreateOneWithoutTasksInputInputObject
      SubprojectCreateWithoutTasksInput: SubprojectCreateWithoutTasksInputInputObject
      TaskUpdateInput: TaskUpdateInputInputObject
      SubprojectUpdateOneWithoutTasksInput: SubprojectUpdateOneWithoutTasksInputInputObject
      SubprojectUpdateWithoutTasksDataInput: SubprojectUpdateWithoutTasksDataInputInputObject
      SubprojectUpsertWithoutTasksInput: SubprojectUpsertWithoutTasksInputInputObject
      TaskUpdateManyMutationInput: TaskUpdateManyMutationInputInputObject
      TimelogCreateInput: TimelogCreateInputInputObject
      TaskCreateOneWithoutTimelogsInput: TaskCreateOneWithoutTimelogsInputInputObject
      TaskCreateWithoutTimelogsInput: TaskCreateWithoutTimelogsInputInputObject
      TimelogUpdateInput: TimelogUpdateInputInputObject
      TaskUpdateOneRequiredWithoutTimelogsInput: TaskUpdateOneRequiredWithoutTimelogsInputInputObject
      TaskUpdateWithoutTimelogsDataInput: TaskUpdateWithoutTimelogsDataInputInputObject
      TaskUpsertWithoutTimelogsInput: TaskUpsertWithoutTimelogsInputInputObject
      TimelogUpdateManyMutationInput: TimelogUpdateManyMutationInputInputObject
      TagCreateInput: TagCreateInputInputObject
      TaskCreateManyWithoutTagsInput: TaskCreateManyWithoutTagsInputInputObject
      TaskCreateWithoutTagsInput: TaskCreateWithoutTagsInputInputObject
      TagUpdateInput: TagUpdateInputInputObject
      TaskUpdateManyWithoutTagsInput: TaskUpdateManyWithoutTagsInputInputObject
      TaskUpdateWithWhereUniqueWithoutTagsInput: TaskUpdateWithWhereUniqueWithoutTagsInputInputObject
      TaskUpdateWithoutTagsDataInput: TaskUpdateWithoutTagsDataInputInputObject
      TaskUpsertWithWhereUniqueWithoutTagsInput: TaskUpsertWithWhereUniqueWithoutTagsInputInputObject
      TagUpdateManyMutationInput: TagUpdateManyMutationInputInputObject
      ProjectSubscriptionWhereInput: ProjectSubscriptionWhereInputInputObject
      SubprojectSubscriptionWhereInput: SubprojectSubscriptionWhereInputInputObject
      TaskSubscriptionWhereInput: TaskSubscriptionWhereInputInputObject
      TimelogSubscriptionWhereInput: TimelogSubscriptionWhereInputInputObject
      TagSubscriptionWhereInput: TagSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    SubprojectOrderByInput: SubprojectOrderByInputValues,
    TaskOrderByInput: TaskOrderByInputValues,
    TimelogOrderByInput: TimelogOrderByInputValues,
    TagOrderByInput: TagOrderByInputValues,
    ProjectOrderByInput: ProjectOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'project', args?: QueryProjectArgs[] | false, alias?: string  } 
  | { name: 'projects', args?: QueryProjectsArgs[] | false, alias?: string  } 
  | { name: 'projectsConnection', args?: QueryProjectsConnectionArgs[] | false, alias?: string  } 
  | { name: 'subproject', args?: QuerySubprojectArgs[] | false, alias?: string  } 
  | { name: 'subprojects', args?: QuerySubprojectsArgs[] | false, alias?: string  } 
  | { name: 'subprojectsConnection', args?: QuerySubprojectsConnectionArgs[] | false, alias?: string  } 
  | { name: 'task', args?: QueryTaskArgs[] | false, alias?: string  } 
  | { name: 'tasks', args?: QueryTasksArgs[] | false, alias?: string  } 
  | { name: 'tasksConnection', args?: QueryTasksConnectionArgs[] | false, alias?: string  } 
  | { name: 'timelog', args?: QueryTimelogArgs[] | false, alias?: string  } 
  | { name: 'timelogs', args?: QueryTimelogsArgs[] | false, alias?: string  } 
  | { name: 'timelogsConnection', args?: QueryTimelogsConnectionArgs[] | false, alias?: string  } 
  | { name: 'tag', args?: QueryTagArgs[] | false, alias?: string  } 
  | { name: 'tags', args?: QueryTagsArgs[] | false, alias?: string  } 
  | { name: 'tagsConnection', args?: QueryTagsConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'project'
  | 'projects'
  | 'projectsConnection'
  | 'subproject'
  | 'subprojects'
  | 'subprojectsConnection'
  | 'task'
  | 'tasks'
  | 'tasksConnection'
  | 'timelog'
  | 'timelogs'
  | 'timelogsConnection'
  | 'tag'
  | 'tags'
  | 'tagsConnection'


type QueryProjectArgs =
  | 'where'
type QueryProjectsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryProjectsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QuerySubprojectArgs =
  | 'where'
type QuerySubprojectsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QuerySubprojectsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTaskArgs =
  | 'where'
type QueryTasksArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTasksConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTimelogArgs =
  | 'where'
type QueryTimelogsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTimelogsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTagArgs =
  | 'where'
type QueryTagsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryTagsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  project: {
    type: 'Project'
    args: Record<QueryProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: ProjectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project | null> | prisma.Project | null
  }
  projects: {
    type: 'Project'
    args: Record<QueryProjectsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ProjectWhereInput | null, orderBy?: prisma.ProjectOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project[]> | prisma.Project[]
  }
  projectsConnection: {
    type: 'ProjectConnection'
    args: Record<QueryProjectsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: ProjectWhereInput | null, orderBy?: prisma.ProjectOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProjectConnection> | prisma.ProjectConnection
  }
  subproject: {
    type: 'Subproject'
    args: Record<QuerySubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: SubprojectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject | null> | prisma.Subproject | null
  }
  subprojects: {
    type: 'Subproject'
    args: Record<QuerySubprojectsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: SubprojectWhereInput | null, orderBy?: prisma.SubprojectOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject[]> | prisma.Subproject[]
  }
  subprojectsConnection: {
    type: 'SubprojectConnection'
    args: Record<QuerySubprojectsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: SubprojectWhereInput | null, orderBy?: prisma.SubprojectOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SubprojectConnection> | prisma.SubprojectConnection
  }
  task: {
    type: 'Task'
    args: Record<QueryTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TaskWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task | null> | prisma.Task | null
  }
  tasks: {
    type: 'Task'
    args: Record<QueryTasksArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TaskWhereInput | null, orderBy?: prisma.TaskOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task[]> | prisma.Task[]
  }
  tasksConnection: {
    type: 'TaskConnection'
    args: Record<QueryTasksConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TaskWhereInput | null, orderBy?: prisma.TaskOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TaskConnection> | prisma.TaskConnection
  }
  timelog: {
    type: 'Timelog'
    args: Record<QueryTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TimelogWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog | null> | prisma.Timelog | null
  }
  timelogs: {
    type: 'Timelog'
    args: Record<QueryTimelogsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TimelogWhereInput | null, orderBy?: prisma.TimelogOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog[]> | prisma.Timelog[]
  }
  timelogsConnection: {
    type: 'TimelogConnection'
    args: Record<QueryTimelogsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TimelogWhereInput | null, orderBy?: prisma.TimelogOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TimelogConnection> | prisma.TimelogConnection
  }
  tag: {
    type: 'Tag'
    args: Record<QueryTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: TagWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag | null> | prisma.Tag | null
  }
  tags: {
    type: 'Tag'
    args: Record<QueryTagsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TagWhereInput | null, orderBy?: prisma.TagOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag[]> | prisma.Tag[]
  }
  tagsConnection: {
    type: 'TagConnection'
    args: Record<QueryTagsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: TagWhereInput | null, orderBy?: prisma.TagOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TagConnection> | prisma.TagConnection
  }
}
  

// Types for Project

type ProjectObject =
  | ProjectFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'subprojects', args?: ProjectSubprojectsArgs[] | false, alias?: string  } 

type ProjectFields =
  | 'id'
  | 'name'
  | 'subprojects'


type ProjectSubprojectsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface ProjectFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  subprojects: {
    type: 'Subproject'
    args: Record<ProjectSubprojectsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Project">,
      args: { where?: SubprojectWhereInput | null, orderBy?: prisma.SubprojectOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject[]> | prisma.Subproject[]
  }
}
  

// Types for Subproject

type SubprojectObject =
  | SubprojectFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'project', args?: [] | false, alias?: string  } 
  | { name: 'tasks', args?: SubprojectTasksArgs[] | false, alias?: string  } 

type SubprojectFields =
  | 'id'
  | 'name'
  | 'project'
  | 'tasks'


type SubprojectTasksArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface SubprojectFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  project: {
    type: 'Project'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Subproject">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project> | prisma.Project
  }
  tasks: {
    type: 'Task'
    args: Record<SubprojectTasksArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Subproject">,
      args: { where?: TaskWhereInput | null, orderBy?: prisma.TaskOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task[]> | prisma.Task[]
  }
}
  

// Types for Task

type TaskObject =
  | TaskFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'priority', args?: [] | false, alias?: string  } 
  | { name: 'comments', args?: [] | false, alias?: string  } 
  | { name: 'repeat', args?: [] | false, alias?: string  } 
  | { name: 'estimateTime', args?: [] | false, alias?: string  } 
  | { name: 'plannedTime', args?: [] | false, alias?: string  } 
  | { name: 'plannedDate', args?: [] | false, alias?: string  } 
  | { name: 'finishDate', args?: [] | false, alias?: string  } 
  | { name: 'deadlineDate', args?: [] | false, alias?: string  } 
  | { name: 'completed', args?: [] | false, alias?: string  } 
  | { name: 'subproject', args?: [] | false, alias?: string  } 
  | { name: 'timelogs', args?: TaskTimelogsArgs[] | false, alias?: string  } 
  | { name: 'tags', args?: TaskTagsArgs[] | false, alias?: string  } 

type TaskFields =
  | 'id'
  | 'name'
  | 'priority'
  | 'comments'
  | 'repeat'
  | 'estimateTime'
  | 'plannedTime'
  | 'plannedDate'
  | 'finishDate'
  | 'deadlineDate'
  | 'completed'
  | 'subproject'
  | 'timelogs'
  | 'tags'


type TaskTimelogsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type TaskTagsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface TaskFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  priority: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  comments: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  repeat: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  estimateTime: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  plannedTime: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  plannedDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  finishDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  deadlineDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  completed: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  subproject: {
    type: 'Subproject'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Task">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject | null> | prisma.Subproject | null
  }
  timelogs: {
    type: 'Timelog'
    args: Record<TaskTimelogsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Task">,
      args: { where?: TimelogWhereInput | null, orderBy?: prisma.TimelogOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog[]> | prisma.Timelog[]
  }
  tags: {
    type: 'Tag'
    args: Record<TaskTagsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Task">,
      args: { where?: TagWhereInput | null, orderBy?: prisma.TagOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag[]> | prisma.Tag[]
  }
}
  

// Types for Timelog

type TimelogObject =
  | TimelogFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'startDate', args?: [] | false, alias?: string  } 
  | { name: 'finishDate', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 
  | { name: 'task', args?: [] | false, alias?: string  } 

type TimelogFields =
  | 'id'
  | 'startDate'
  | 'finishDate'
  | 'description'
  | 'task'



  

export interface TimelogFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startDate: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  finishDate: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  task: {
    type: 'Task'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Timelog">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task> | prisma.Task
  }
}
  

// Types for Tag

type TagObject =
  | TagFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'tasks', args?: TagTasksArgs[] | false, alias?: string  } 

type TagFields =
  | 'id'
  | 'name'
  | 'tasks'


type TagTasksArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface TagFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  tasks: {
    type: 'Task'
    args: Record<TagTasksArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Tag">,
      args: { where?: TaskWhereInput | null, orderBy?: prisma.TaskOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task[]> | prisma.Task[]
  }
}
  

// Types for ProjectConnection

type ProjectConnectionObject =
  | ProjectConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type ProjectConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface ProjectConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProjectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'ProjectEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"ProjectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProjectEdge[]> | prisma.ProjectEdge[]
  }
  aggregate: {
    type: 'AggregateProject'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProjectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateProject> | prisma.AggregateProject
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for ProjectEdge

type ProjectEdgeObject =
  | ProjectEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type ProjectEdgeFields =
  | 'node'
  | 'cursor'



  

export interface ProjectEdgeFieldDetails {
  node: {
    type: 'Project'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProjectEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project> | prisma.Project
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateProject

type AggregateProjectObject =
  | AggregateProjectFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateProjectFields =
  | 'count'



  

export interface AggregateProjectFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for SubprojectConnection

type SubprojectConnectionObject =
  | SubprojectConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type SubprojectConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface SubprojectConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SubprojectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'SubprojectEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"SubprojectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SubprojectEdge[]> | prisma.SubprojectEdge[]
  }
  aggregate: {
    type: 'AggregateSubproject'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SubprojectConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateSubproject> | prisma.AggregateSubproject
  }
}
  

// Types for SubprojectEdge

type SubprojectEdgeObject =
  | SubprojectEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type SubprojectEdgeFields =
  | 'node'
  | 'cursor'



  

export interface SubprojectEdgeFieldDetails {
  node: {
    type: 'Subproject'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SubprojectEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject> | prisma.Subproject
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateSubproject

type AggregateSubprojectObject =
  | AggregateSubprojectFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateSubprojectFields =
  | 'count'



  

export interface AggregateSubprojectFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TaskConnection

type TaskConnectionObject =
  | TaskConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TaskConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TaskConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TaskConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TaskEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TaskConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TaskEdge[]> | prisma.TaskEdge[]
  }
  aggregate: {
    type: 'AggregateTask'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TaskConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateTask> | prisma.AggregateTask
  }
}
  

// Types for TaskEdge

type TaskEdgeObject =
  | TaskEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TaskEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TaskEdgeFieldDetails {
  node: {
    type: 'Task'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TaskEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task> | prisma.Task
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateTask

type AggregateTaskObject =
  | AggregateTaskFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTaskFields =
  | 'count'



  

export interface AggregateTaskFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TimelogConnection

type TimelogConnectionObject =
  | TimelogConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TimelogConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TimelogConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TimelogConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TimelogEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TimelogConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TimelogEdge[]> | prisma.TimelogEdge[]
  }
  aggregate: {
    type: 'AggregateTimelog'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TimelogConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateTimelog> | prisma.AggregateTimelog
  }
}
  

// Types for TimelogEdge

type TimelogEdgeObject =
  | TimelogEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TimelogEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TimelogEdgeFieldDetails {
  node: {
    type: 'Timelog'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TimelogEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog> | prisma.Timelog
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateTimelog

type AggregateTimelogObject =
  | AggregateTimelogFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTimelogFields =
  | 'count'



  

export interface AggregateTimelogFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TagConnection

type TagConnectionObject =
  | TagConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type TagConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface TagConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TagConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'TagEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"TagConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TagEdge[]> | prisma.TagEdge[]
  }
  aggregate: {
    type: 'AggregateTag'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TagConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateTag> | prisma.AggregateTag
  }
}
  

// Types for TagEdge

type TagEdgeObject =
  | TagEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type TagEdgeFields =
  | 'node'
  | 'cursor'



  

export interface TagEdgeFieldDetails {
  node: {
    type: 'Tag'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TagEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag> | prisma.Tag
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateTag

type AggregateTagObject =
  | AggregateTagFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateTagFields =
  | 'count'



  

export interface AggregateTagFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createProject', args?: MutationCreateProjectArgs[] | false, alias?: string  } 
  | { name: 'updateProject', args?: MutationUpdateProjectArgs[] | false, alias?: string  } 
  | { name: 'updateManyProjects', args?: MutationUpdateManyProjectsArgs[] | false, alias?: string  } 
  | { name: 'upsertProject', args?: MutationUpsertProjectArgs[] | false, alias?: string  } 
  | { name: 'deleteProject', args?: MutationDeleteProjectArgs[] | false, alias?: string  } 
  | { name: 'deleteManyProjects', args?: MutationDeleteManyProjectsArgs[] | false, alias?: string  } 
  | { name: 'createSubproject', args?: MutationCreateSubprojectArgs[] | false, alias?: string  } 
  | { name: 'updateSubproject', args?: MutationUpdateSubprojectArgs[] | false, alias?: string  } 
  | { name: 'updateManySubprojects', args?: MutationUpdateManySubprojectsArgs[] | false, alias?: string  } 
  | { name: 'upsertSubproject', args?: MutationUpsertSubprojectArgs[] | false, alias?: string  } 
  | { name: 'deleteSubproject', args?: MutationDeleteSubprojectArgs[] | false, alias?: string  } 
  | { name: 'deleteManySubprojects', args?: MutationDeleteManySubprojectsArgs[] | false, alias?: string  } 
  | { name: 'createTask', args?: MutationCreateTaskArgs[] | false, alias?: string  } 
  | { name: 'updateTask', args?: MutationUpdateTaskArgs[] | false, alias?: string  } 
  | { name: 'updateManyTasks', args?: MutationUpdateManyTasksArgs[] | false, alias?: string  } 
  | { name: 'upsertTask', args?: MutationUpsertTaskArgs[] | false, alias?: string  } 
  | { name: 'deleteTask', args?: MutationDeleteTaskArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTasks', args?: MutationDeleteManyTasksArgs[] | false, alias?: string  } 
  | { name: 'createTimelog', args?: MutationCreateTimelogArgs[] | false, alias?: string  } 
  | { name: 'updateTimelog', args?: MutationUpdateTimelogArgs[] | false, alias?: string  } 
  | { name: 'updateManyTimelogs', args?: MutationUpdateManyTimelogsArgs[] | false, alias?: string  } 
  | { name: 'upsertTimelog', args?: MutationUpsertTimelogArgs[] | false, alias?: string  } 
  | { name: 'deleteTimelog', args?: MutationDeleteTimelogArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTimelogs', args?: MutationDeleteManyTimelogsArgs[] | false, alias?: string  } 
  | { name: 'createTag', args?: MutationCreateTagArgs[] | false, alias?: string  } 
  | { name: 'updateTag', args?: MutationUpdateTagArgs[] | false, alias?: string  } 
  | { name: 'updateManyTags', args?: MutationUpdateManyTagsArgs[] | false, alias?: string  } 
  | { name: 'upsertTag', args?: MutationUpsertTagArgs[] | false, alias?: string  } 
  | { name: 'deleteTag', args?: MutationDeleteTagArgs[] | false, alias?: string  } 
  | { name: 'deleteManyTags', args?: MutationDeleteManyTagsArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createProject'
  | 'updateProject'
  | 'updateManyProjects'
  | 'upsertProject'
  | 'deleteProject'
  | 'deleteManyProjects'
  | 'createSubproject'
  | 'updateSubproject'
  | 'updateManySubprojects'
  | 'upsertSubproject'
  | 'deleteSubproject'
  | 'deleteManySubprojects'
  | 'createTask'
  | 'updateTask'
  | 'updateManyTasks'
  | 'upsertTask'
  | 'deleteTask'
  | 'deleteManyTasks'
  | 'createTimelog'
  | 'updateTimelog'
  | 'updateManyTimelogs'
  | 'upsertTimelog'
  | 'deleteTimelog'
  | 'deleteManyTimelogs'
  | 'createTag'
  | 'updateTag'
  | 'updateManyTags'
  | 'upsertTag'
  | 'deleteTag'
  | 'deleteManyTags'


type MutationCreateProjectArgs =
  | 'data'
type MutationUpdateProjectArgs =
  | 'data'
  | 'where'
type MutationUpdateManyProjectsArgs =
  | 'data'
  | 'where'
type MutationUpsertProjectArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteProjectArgs =
  | 'where'
type MutationDeleteManyProjectsArgs =
  | 'where'
type MutationCreateSubprojectArgs =
  | 'data'
type MutationUpdateSubprojectArgs =
  | 'data'
  | 'where'
type MutationUpdateManySubprojectsArgs =
  | 'data'
  | 'where'
type MutationUpsertSubprojectArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteSubprojectArgs =
  | 'where'
type MutationDeleteManySubprojectsArgs =
  | 'where'
type MutationCreateTaskArgs =
  | 'data'
type MutationUpdateTaskArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTasksArgs =
  | 'data'
  | 'where'
type MutationUpsertTaskArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTaskArgs =
  | 'where'
type MutationDeleteManyTasksArgs =
  | 'where'
type MutationCreateTimelogArgs =
  | 'data'
type MutationUpdateTimelogArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTimelogsArgs =
  | 'data'
  | 'where'
type MutationUpsertTimelogArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTimelogArgs =
  | 'where'
type MutationDeleteManyTimelogsArgs =
  | 'where'
type MutationCreateTagArgs =
  | 'data'
type MutationUpdateTagArgs =
  | 'data'
  | 'where'
type MutationUpdateManyTagsArgs =
  | 'data'
  | 'where'
type MutationUpsertTagArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteTagArgs =
  | 'where'
type MutationDeleteManyTagsArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createProject: {
    type: 'Project'
    args: Record<MutationCreateProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProjectCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project> | prisma.Project
  }
  updateProject: {
    type: 'Project'
    args: Record<MutationUpdateProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProjectUpdateInput, where: ProjectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project | null> | prisma.Project | null
  }
  updateManyProjects: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyProjectsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: ProjectUpdateManyMutationInput, where?: ProjectWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertProject: {
    type: 'Project'
    args: Record<MutationUpsertProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ProjectWhereUniqueInput, create: ProjectCreateInput, update: ProjectUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project> | prisma.Project
  }
  deleteProject: {
    type: 'Project'
    args: Record<MutationDeleteProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: ProjectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project | null> | prisma.Project | null
  }
  deleteManyProjects: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyProjectsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: ProjectWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createSubproject: {
    type: 'Subproject'
    args: Record<MutationCreateSubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SubprojectCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject> | prisma.Subproject
  }
  updateSubproject: {
    type: 'Subproject'
    args: Record<MutationUpdateSubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SubprojectUpdateInput, where: SubprojectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject | null> | prisma.Subproject | null
  }
  updateManySubprojects: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManySubprojectsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: SubprojectUpdateManyMutationInput, where?: SubprojectWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertSubproject: {
    type: 'Subproject'
    args: Record<MutationUpsertSubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: SubprojectWhereUniqueInput, create: SubprojectCreateInput, update: SubprojectUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject> | prisma.Subproject
  }
  deleteSubproject: {
    type: 'Subproject'
    args: Record<MutationDeleteSubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: SubprojectWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject | null> | prisma.Subproject | null
  }
  deleteManySubprojects: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManySubprojectsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: SubprojectWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createTask: {
    type: 'Task'
    args: Record<MutationCreateTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TaskCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task> | prisma.Task
  }
  updateTask: {
    type: 'Task'
    args: Record<MutationUpdateTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TaskUpdateInput, where: TaskWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task | null> | prisma.Task | null
  }
  updateManyTasks: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTasksArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TaskUpdateManyMutationInput, where?: TaskWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertTask: {
    type: 'Task'
    args: Record<MutationUpsertTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TaskWhereUniqueInput, create: TaskCreateInput, update: TaskUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task> | prisma.Task
  }
  deleteTask: {
    type: 'Task'
    args: Record<MutationDeleteTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TaskWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task | null> | prisma.Task | null
  }
  deleteManyTasks: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTasksArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TaskWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createTimelog: {
    type: 'Timelog'
    args: Record<MutationCreateTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TimelogCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog> | prisma.Timelog
  }
  updateTimelog: {
    type: 'Timelog'
    args: Record<MutationUpdateTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TimelogUpdateInput, where: TimelogWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog | null> | prisma.Timelog | null
  }
  updateManyTimelogs: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTimelogsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TimelogUpdateManyMutationInput, where?: TimelogWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertTimelog: {
    type: 'Timelog'
    args: Record<MutationUpsertTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TimelogWhereUniqueInput, create: TimelogCreateInput, update: TimelogUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog> | prisma.Timelog
  }
  deleteTimelog: {
    type: 'Timelog'
    args: Record<MutationDeleteTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TimelogWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog | null> | prisma.Timelog | null
  }
  deleteManyTimelogs: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTimelogsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TimelogWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createTag: {
    type: 'Tag'
    args: Record<MutationCreateTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TagCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag> | prisma.Tag
  }
  updateTag: {
    type: 'Tag'
    args: Record<MutationUpdateTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TagUpdateInput, where: TagWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag | null> | prisma.Tag | null
  }
  updateManyTags: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyTagsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: TagUpdateManyMutationInput, where?: TagWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertTag: {
    type: 'Tag'
    args: Record<MutationUpsertTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TagWhereUniqueInput, create: TagCreateInput, update: TagUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag> | prisma.Tag
  }
  deleteTag: {
    type: 'Tag'
    args: Record<MutationDeleteTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: TagWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag | null> | prisma.Tag | null
  }
  deleteManyTags: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyTagsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: TagWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'project', args?: SubscriptionProjectArgs[] | false, alias?: string  } 
  | { name: 'subproject', args?: SubscriptionSubprojectArgs[] | false, alias?: string  } 
  | { name: 'task', args?: SubscriptionTaskArgs[] | false, alias?: string  } 
  | { name: 'timelog', args?: SubscriptionTimelogArgs[] | false, alias?: string  } 
  | { name: 'tag', args?: SubscriptionTagArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'project'
  | 'subproject'
  | 'task'
  | 'timelog'
  | 'tag'


type SubscriptionProjectArgs =
  | 'where'
type SubscriptionSubprojectArgs =
  | 'where'
type SubscriptionTaskArgs =
  | 'where'
type SubscriptionTimelogArgs =
  | 'where'
type SubscriptionTagArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  project: {
    type: 'ProjectSubscriptionPayload'
    args: Record<SubscriptionProjectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: ProjectSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProjectSubscriptionPayload | null> | prisma.ProjectSubscriptionPayload | null
  }
  subproject: {
    type: 'SubprojectSubscriptionPayload'
    args: Record<SubscriptionSubprojectArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: SubprojectSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SubprojectSubscriptionPayload | null> | prisma.SubprojectSubscriptionPayload | null
  }
  task: {
    type: 'TaskSubscriptionPayload'
    args: Record<SubscriptionTaskArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TaskSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TaskSubscriptionPayload | null> | prisma.TaskSubscriptionPayload | null
  }
  timelog: {
    type: 'TimelogSubscriptionPayload'
    args: Record<SubscriptionTimelogArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TimelogSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TimelogSubscriptionPayload | null> | prisma.TimelogSubscriptionPayload | null
  }
  tag: {
    type: 'TagSubscriptionPayload'
    args: Record<SubscriptionTagArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: TagSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TagSubscriptionPayload | null> | prisma.TagSubscriptionPayload | null
  }
}
  

// Types for ProjectSubscriptionPayload

type ProjectSubscriptionPayloadObject =
  | ProjectSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type ProjectSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface ProjectSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"ProjectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Project'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ProjectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Project | null> | prisma.Project | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'ProjectPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"ProjectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.ProjectPreviousValues | null> | prisma.ProjectPreviousValues | null
  }
}
  

// Types for ProjectPreviousValues

type ProjectPreviousValuesObject =
  | ProjectPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type ProjectPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface ProjectPreviousValuesFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for SubprojectSubscriptionPayload

type SubprojectSubscriptionPayloadObject =
  | SubprojectSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type SubprojectSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface SubprojectSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"SubprojectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Subproject'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"SubprojectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Subproject | null> | prisma.Subproject | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'SubprojectPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"SubprojectSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.SubprojectPreviousValues | null> | prisma.SubprojectPreviousValues | null
  }
}
  

// Types for SubprojectPreviousValues

type SubprojectPreviousValuesObject =
  | SubprojectPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type SubprojectPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface SubprojectPreviousValuesFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TaskSubscriptionPayload

type TaskSubscriptionPayloadObject =
  | TaskSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TaskSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TaskSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TaskSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Task'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TaskSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Task | null> | prisma.Task | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TaskPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TaskSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TaskPreviousValues | null> | prisma.TaskPreviousValues | null
  }
}
  

// Types for TaskPreviousValues

type TaskPreviousValuesObject =
  | TaskPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'priority', args?: [] | false, alias?: string  } 
  | { name: 'comments', args?: [] | false, alias?: string  } 
  | { name: 'repeat', args?: [] | false, alias?: string  } 
  | { name: 'estimateTime', args?: [] | false, alias?: string  } 
  | { name: 'plannedTime', args?: [] | false, alias?: string  } 
  | { name: 'plannedDate', args?: [] | false, alias?: string  } 
  | { name: 'finishDate', args?: [] | false, alias?: string  } 
  | { name: 'deadlineDate', args?: [] | false, alias?: string  } 
  | { name: 'completed', args?: [] | false, alias?: string  } 

type TaskPreviousValuesFields =
  | 'id'
  | 'name'
  | 'priority'
  | 'comments'
  | 'repeat'
  | 'estimateTime'
  | 'plannedTime'
  | 'plannedDate'
  | 'finishDate'
  | 'deadlineDate'
  | 'completed'



  

export interface TaskPreviousValuesFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  priority: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  comments: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  repeat: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  estimateTime: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  plannedTime: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  plannedDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  finishDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  deadlineDate: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  completed: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for TimelogSubscriptionPayload

type TimelogSubscriptionPayloadObject =
  | TimelogSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TimelogSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TimelogSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TimelogSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Timelog'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TimelogSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Timelog | null> | prisma.Timelog | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TimelogPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TimelogSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TimelogPreviousValues | null> | prisma.TimelogPreviousValues | null
  }
}
  

// Types for TimelogPreviousValues

type TimelogPreviousValuesObject =
  | TimelogPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'startDate', args?: [] | false, alias?: string  } 
  | { name: 'finishDate', args?: [] | false, alias?: string  } 
  | { name: 'description', args?: [] | false, alias?: string  } 

type TimelogPreviousValuesFields =
  | 'id'
  | 'startDate'
  | 'finishDate'
  | 'description'



  

export interface TimelogPreviousValuesFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startDate: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  finishDate: {
    type: 'DateTime'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  description: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for TagSubscriptionPayload

type TagSubscriptionPayloadObject =
  | TagSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type TagSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface TagSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"TagSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Tag'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TagSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Tag | null> | prisma.Tag | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'TagPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"TagSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.TagPreviousValues | null> | prisma.TagPreviousValues | null
  }
}
  

// Types for TagPreviousValues

type TagPreviousValuesObject =
  | TagPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type TagPreviousValuesFields =
  | 'id'
  | 'name'



  

export interface TagPreviousValuesFieldDetails {
  id: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  


export interface ProjectWhereUniqueInput {
  id?: number | null
  name?: string | null
}
export type ProjectWhereUniqueInputInputObject =
  | Extract<keyof ProjectWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface SubprojectWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  project?: ProjectWhereInput | null
  tasks_every?: TaskWhereInput | null
  tasks_some?: TaskWhereInput | null
  tasks_none?: TaskWhereInput | null
  AND?: SubprojectWhereInput[]
  OR?: SubprojectWhereInput[]
  NOT?: SubprojectWhereInput[]
}
export type SubprojectWhereInputInputObject =
  | Extract<keyof SubprojectWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'project', alias?: string  } 
  | { name: 'tasks_every', alias?: string  } 
  | { name: 'tasks_some', alias?: string  } 
  | { name: 'tasks_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface ProjectWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  subprojects_every?: SubprojectWhereInput | null
  subprojects_some?: SubprojectWhereInput | null
  subprojects_none?: SubprojectWhereInput | null
  AND?: ProjectWhereInput[]
  OR?: ProjectWhereInput[]
  NOT?: ProjectWhereInput[]
}
export type ProjectWhereInputInputObject =
  | Extract<keyof ProjectWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'subprojects_every', alias?: string  } 
  | { name: 'subprojects_some', alias?: string  } 
  | { name: 'subprojects_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TaskWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  priority?: string | null
  priority_not?: string | null
  priority_in?: string[]
  priority_not_in?: string[]
  priority_lt?: string | null
  priority_lte?: string | null
  priority_gt?: string | null
  priority_gte?: string | null
  priority_contains?: string | null
  priority_not_contains?: string | null
  priority_starts_with?: string | null
  priority_not_starts_with?: string | null
  priority_ends_with?: string | null
  priority_not_ends_with?: string | null
  comments?: string | null
  comments_not?: string | null
  comments_in?: string[]
  comments_not_in?: string[]
  comments_lt?: string | null
  comments_lte?: string | null
  comments_gt?: string | null
  comments_gte?: string | null
  comments_contains?: string | null
  comments_not_contains?: string | null
  comments_starts_with?: string | null
  comments_not_starts_with?: string | null
  comments_ends_with?: string | null
  comments_not_ends_with?: string | null
  repeat?: number | null
  repeat_not?: number | null
  repeat_in?: number[]
  repeat_not_in?: number[]
  repeat_lt?: number | null
  repeat_lte?: number | null
  repeat_gt?: number | null
  repeat_gte?: number | null
  estimateTime?: string | null
  estimateTime_not?: string | null
  estimateTime_in?: string[]
  estimateTime_not_in?: string[]
  estimateTime_lt?: string | null
  estimateTime_lte?: string | null
  estimateTime_gt?: string | null
  estimateTime_gte?: string | null
  estimateTime_contains?: string | null
  estimateTime_not_contains?: string | null
  estimateTime_starts_with?: string | null
  estimateTime_not_starts_with?: string | null
  estimateTime_ends_with?: string | null
  estimateTime_not_ends_with?: string | null
  plannedTime?: string | null
  plannedTime_not?: string | null
  plannedTime_in?: string[]
  plannedTime_not_in?: string[]
  plannedTime_lt?: string | null
  plannedTime_lte?: string | null
  plannedTime_gt?: string | null
  plannedTime_gte?: string | null
  plannedTime_contains?: string | null
  plannedTime_not_contains?: string | null
  plannedTime_starts_with?: string | null
  plannedTime_not_starts_with?: string | null
  plannedTime_ends_with?: string | null
  plannedTime_not_ends_with?: string | null
  plannedDate?: string | null
  plannedDate_not?: string | null
  plannedDate_in?: string[]
  plannedDate_not_in?: string[]
  plannedDate_lt?: string | null
  plannedDate_lte?: string | null
  plannedDate_gt?: string | null
  plannedDate_gte?: string | null
  plannedDate_contains?: string | null
  plannedDate_not_contains?: string | null
  plannedDate_starts_with?: string | null
  plannedDate_not_starts_with?: string | null
  plannedDate_ends_with?: string | null
  plannedDate_not_ends_with?: string | null
  finishDate?: string | null
  finishDate_not?: string | null
  finishDate_in?: string[]
  finishDate_not_in?: string[]
  finishDate_lt?: string | null
  finishDate_lte?: string | null
  finishDate_gt?: string | null
  finishDate_gte?: string | null
  finishDate_contains?: string | null
  finishDate_not_contains?: string | null
  finishDate_starts_with?: string | null
  finishDate_not_starts_with?: string | null
  finishDate_ends_with?: string | null
  finishDate_not_ends_with?: string | null
  deadlineDate?: string | null
  deadlineDate_not?: string | null
  deadlineDate_in?: string[]
  deadlineDate_not_in?: string[]
  deadlineDate_lt?: string | null
  deadlineDate_lte?: string | null
  deadlineDate_gt?: string | null
  deadlineDate_gte?: string | null
  deadlineDate_contains?: string | null
  deadlineDate_not_contains?: string | null
  deadlineDate_starts_with?: string | null
  deadlineDate_not_starts_with?: string | null
  deadlineDate_ends_with?: string | null
  deadlineDate_not_ends_with?: string | null
  completed?: boolean | null
  completed_not?: boolean | null
  subproject?: SubprojectWhereInput | null
  timelogs_every?: TimelogWhereInput | null
  timelogs_some?: TimelogWhereInput | null
  timelogs_none?: TimelogWhereInput | null
  tags_every?: TagWhereInput | null
  tags_some?: TagWhereInput | null
  tags_none?: TagWhereInput | null
  AND?: TaskWhereInput[]
  OR?: TaskWhereInput[]
  NOT?: TaskWhereInput[]
}
export type TaskWhereInputInputObject =
  | Extract<keyof TaskWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'priority_not', alias?: string  } 
  | { name: 'priority_in', alias?: string  } 
  | { name: 'priority_not_in', alias?: string  } 
  | { name: 'priority_lt', alias?: string  } 
  | { name: 'priority_lte', alias?: string  } 
  | { name: 'priority_gt', alias?: string  } 
  | { name: 'priority_gte', alias?: string  } 
  | { name: 'priority_contains', alias?: string  } 
  | { name: 'priority_not_contains', alias?: string  } 
  | { name: 'priority_starts_with', alias?: string  } 
  | { name: 'priority_not_starts_with', alias?: string  } 
  | { name: 'priority_ends_with', alias?: string  } 
  | { name: 'priority_not_ends_with', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'comments_not', alias?: string  } 
  | { name: 'comments_in', alias?: string  } 
  | { name: 'comments_not_in', alias?: string  } 
  | { name: 'comments_lt', alias?: string  } 
  | { name: 'comments_lte', alias?: string  } 
  | { name: 'comments_gt', alias?: string  } 
  | { name: 'comments_gte', alias?: string  } 
  | { name: 'comments_contains', alias?: string  } 
  | { name: 'comments_not_contains', alias?: string  } 
  | { name: 'comments_starts_with', alias?: string  } 
  | { name: 'comments_not_starts_with', alias?: string  } 
  | { name: 'comments_ends_with', alias?: string  } 
  | { name: 'comments_not_ends_with', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'repeat_not', alias?: string  } 
  | { name: 'repeat_in', alias?: string  } 
  | { name: 'repeat_not_in', alias?: string  } 
  | { name: 'repeat_lt', alias?: string  } 
  | { name: 'repeat_lte', alias?: string  } 
  | { name: 'repeat_gt', alias?: string  } 
  | { name: 'repeat_gte', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'estimateTime_not', alias?: string  } 
  | { name: 'estimateTime_in', alias?: string  } 
  | { name: 'estimateTime_not_in', alias?: string  } 
  | { name: 'estimateTime_lt', alias?: string  } 
  | { name: 'estimateTime_lte', alias?: string  } 
  | { name: 'estimateTime_gt', alias?: string  } 
  | { name: 'estimateTime_gte', alias?: string  } 
  | { name: 'estimateTime_contains', alias?: string  } 
  | { name: 'estimateTime_not_contains', alias?: string  } 
  | { name: 'estimateTime_starts_with', alias?: string  } 
  | { name: 'estimateTime_not_starts_with', alias?: string  } 
  | { name: 'estimateTime_ends_with', alias?: string  } 
  | { name: 'estimateTime_not_ends_with', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedTime_not', alias?: string  } 
  | { name: 'plannedTime_in', alias?: string  } 
  | { name: 'plannedTime_not_in', alias?: string  } 
  | { name: 'plannedTime_lt', alias?: string  } 
  | { name: 'plannedTime_lte', alias?: string  } 
  | { name: 'plannedTime_gt', alias?: string  } 
  | { name: 'plannedTime_gte', alias?: string  } 
  | { name: 'plannedTime_contains', alias?: string  } 
  | { name: 'plannedTime_not_contains', alias?: string  } 
  | { name: 'plannedTime_starts_with', alias?: string  } 
  | { name: 'plannedTime_not_starts_with', alias?: string  } 
  | { name: 'plannedTime_ends_with', alias?: string  } 
  | { name: 'plannedTime_not_ends_with', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'plannedDate_not', alias?: string  } 
  | { name: 'plannedDate_in', alias?: string  } 
  | { name: 'plannedDate_not_in', alias?: string  } 
  | { name: 'plannedDate_lt', alias?: string  } 
  | { name: 'plannedDate_lte', alias?: string  } 
  | { name: 'plannedDate_gt', alias?: string  } 
  | { name: 'plannedDate_gte', alias?: string  } 
  | { name: 'plannedDate_contains', alias?: string  } 
  | { name: 'plannedDate_not_contains', alias?: string  } 
  | { name: 'plannedDate_starts_with', alias?: string  } 
  | { name: 'plannedDate_not_starts_with', alias?: string  } 
  | { name: 'plannedDate_ends_with', alias?: string  } 
  | { name: 'plannedDate_not_ends_with', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'finishDate_not', alias?: string  } 
  | { name: 'finishDate_in', alias?: string  } 
  | { name: 'finishDate_not_in', alias?: string  } 
  | { name: 'finishDate_lt', alias?: string  } 
  | { name: 'finishDate_lte', alias?: string  } 
  | { name: 'finishDate_gt', alias?: string  } 
  | { name: 'finishDate_gte', alias?: string  } 
  | { name: 'finishDate_contains', alias?: string  } 
  | { name: 'finishDate_not_contains', alias?: string  } 
  | { name: 'finishDate_starts_with', alias?: string  } 
  | { name: 'finishDate_not_starts_with', alias?: string  } 
  | { name: 'finishDate_ends_with', alias?: string  } 
  | { name: 'finishDate_not_ends_with', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'deadlineDate_not', alias?: string  } 
  | { name: 'deadlineDate_in', alias?: string  } 
  | { name: 'deadlineDate_not_in', alias?: string  } 
  | { name: 'deadlineDate_lt', alias?: string  } 
  | { name: 'deadlineDate_lte', alias?: string  } 
  | { name: 'deadlineDate_gt', alias?: string  } 
  | { name: 'deadlineDate_gte', alias?: string  } 
  | { name: 'deadlineDate_contains', alias?: string  } 
  | { name: 'deadlineDate_not_contains', alias?: string  } 
  | { name: 'deadlineDate_starts_with', alias?: string  } 
  | { name: 'deadlineDate_not_starts_with', alias?: string  } 
  | { name: 'deadlineDate_ends_with', alias?: string  } 
  | { name: 'deadlineDate_not_ends_with', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'completed_not', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'timelogs_every', alias?: string  } 
  | { name: 'timelogs_some', alias?: string  } 
  | { name: 'timelogs_none', alias?: string  } 
  | { name: 'tags_every', alias?: string  } 
  | { name: 'tags_some', alias?: string  } 
  | { name: 'tags_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TimelogWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  startDate?: string | null
  startDate_not?: string | null
  startDate_in?: string[]
  startDate_not_in?: string[]
  startDate_lt?: string | null
  startDate_lte?: string | null
  startDate_gt?: string | null
  startDate_gte?: string | null
  finishDate?: string | null
  finishDate_not?: string | null
  finishDate_in?: string[]
  finishDate_not_in?: string[]
  finishDate_lt?: string | null
  finishDate_lte?: string | null
  finishDate_gt?: string | null
  finishDate_gte?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  task?: TaskWhereInput | null
  AND?: TimelogWhereInput[]
  OR?: TimelogWhereInput[]
  NOT?: TimelogWhereInput[]
}
export type TimelogWhereInputInputObject =
  | Extract<keyof TimelogWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'startDate', alias?: string  } 
  | { name: 'startDate_not', alias?: string  } 
  | { name: 'startDate_in', alias?: string  } 
  | { name: 'startDate_not_in', alias?: string  } 
  | { name: 'startDate_lt', alias?: string  } 
  | { name: 'startDate_lte', alias?: string  } 
  | { name: 'startDate_gt', alias?: string  } 
  | { name: 'startDate_gte', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'finishDate_not', alias?: string  } 
  | { name: 'finishDate_in', alias?: string  } 
  | { name: 'finishDate_not_in', alias?: string  } 
  | { name: 'finishDate_lt', alias?: string  } 
  | { name: 'finishDate_lte', alias?: string  } 
  | { name: 'finishDate_gt', alias?: string  } 
  | { name: 'finishDate_gte', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'task', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TagWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  tasks_every?: TaskWhereInput | null
  tasks_some?: TaskWhereInput | null
  tasks_none?: TaskWhereInput | null
  AND?: TagWhereInput[]
  OR?: TagWhereInput[]
  NOT?: TagWhereInput[]
}
export type TagWhereInputInputObject =
  | Extract<keyof TagWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'tasks_every', alias?: string  } 
  | { name: 'tasks_some', alias?: string  } 
  | { name: 'tasks_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SubprojectWhereUniqueInput {
  id?: number | null
  name?: string | null
}
export type SubprojectWhereUniqueInputInputObject =
  | Extract<keyof SubprojectWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface TaskWhereUniqueInput {
  id?: number | null
}
export type TaskWhereUniqueInputInputObject =
  | Extract<keyof TaskWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface TimelogWhereUniqueInput {
  id?: number | null
}
export type TimelogWhereUniqueInputInputObject =
  | Extract<keyof TimelogWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface TagWhereUniqueInput {
  id?: number | null
  name?: string | null
}
export type TagWhereUniqueInputInputObject =
  | Extract<keyof TagWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface ProjectCreateInput {
  id?: number | null
  name?: string
  subprojects?: SubprojectCreateManyWithoutProjectInput | null
}
export type ProjectCreateInputInputObject =
  | Extract<keyof ProjectCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'subprojects', alias?: string  } 
  
export interface SubprojectCreateManyWithoutProjectInput {
  create?: SubprojectCreateWithoutProjectInput[]
  connect?: SubprojectWhereUniqueInput[]
}
export type SubprojectCreateManyWithoutProjectInputInputObject =
  | Extract<keyof SubprojectCreateManyWithoutProjectInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SubprojectCreateWithoutProjectInput {
  id?: number | null
  name?: string
  tasks?: TaskCreateManyWithoutSubprojectInput | null
}
export type SubprojectCreateWithoutProjectInputInputObject =
  | Extract<keyof SubprojectCreateWithoutProjectInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface TaskCreateManyWithoutSubprojectInput {
  create?: TaskCreateWithoutSubprojectInput[]
  connect?: TaskWhereUniqueInput[]
}
export type TaskCreateManyWithoutSubprojectInputInputObject =
  | Extract<keyof TaskCreateManyWithoutSubprojectInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TaskCreateWithoutSubprojectInput {
  id?: number | null
  name?: string
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  timelogs?: TimelogCreateManyWithoutTaskInput | null
  tags?: TagCreateManyWithoutTasksInput | null
}
export type TaskCreateWithoutSubprojectInputInputObject =
  | Extract<keyof TaskCreateWithoutSubprojectInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface TimelogCreateManyWithoutTaskInput {
  create?: TimelogCreateWithoutTaskInput[]
  connect?: TimelogWhereUniqueInput[]
}
export type TimelogCreateManyWithoutTaskInputInputObject =
  | Extract<keyof TimelogCreateManyWithoutTaskInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TimelogCreateWithoutTaskInput {
  id?: number | null
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
}
export type TimelogCreateWithoutTaskInputInputObject =
  | Extract<keyof TimelogCreateWithoutTaskInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface TagCreateManyWithoutTasksInput {
  create?: TagCreateWithoutTasksInput[]
  connect?: TagWhereUniqueInput[]
}
export type TagCreateManyWithoutTasksInputInputObject =
  | Extract<keyof TagCreateManyWithoutTasksInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TagCreateWithoutTasksInput {
  id?: number | null
  name?: string
}
export type TagCreateWithoutTasksInputInputObject =
  | Extract<keyof TagCreateWithoutTasksInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface ProjectUpdateInput {
  name?: string | null
  subprojects?: SubprojectUpdateManyWithoutProjectInput | null
}
export type ProjectUpdateInputInputObject =
  | Extract<keyof ProjectUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'subprojects', alias?: string  } 
  
export interface SubprojectUpdateManyWithoutProjectInput {
  create?: SubprojectCreateWithoutProjectInput[]
  delete?: SubprojectWhereUniqueInput[]
  connect?: SubprojectWhereUniqueInput[]
  set?: SubprojectWhereUniqueInput[]
  disconnect?: SubprojectWhereUniqueInput[]
  update?: SubprojectUpdateWithWhereUniqueWithoutProjectInput[]
  upsert?: SubprojectUpsertWithWhereUniqueWithoutProjectInput[]
  deleteMany?: SubprojectScalarWhereInput[]
  updateMany?: SubprojectUpdateManyWithWhereNestedInput[]
}
export type SubprojectUpdateManyWithoutProjectInputInputObject =
  | Extract<keyof SubprojectUpdateManyWithoutProjectInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface SubprojectUpdateWithWhereUniqueWithoutProjectInput {
  where?: SubprojectWhereUniqueInput
  data?: SubprojectUpdateWithoutProjectDataInput
}
export type SubprojectUpdateWithWhereUniqueWithoutProjectInputInputObject =
  | Extract<keyof SubprojectUpdateWithWhereUniqueWithoutProjectInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface SubprojectUpdateWithoutProjectDataInput {
  name?: string | null
  tasks?: TaskUpdateManyWithoutSubprojectInput | null
}
export type SubprojectUpdateWithoutProjectDataInputInputObject =
  | Extract<keyof SubprojectUpdateWithoutProjectDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface TaskUpdateManyWithoutSubprojectInput {
  create?: TaskCreateWithoutSubprojectInput[]
  delete?: TaskWhereUniqueInput[]
  connect?: TaskWhereUniqueInput[]
  set?: TaskWhereUniqueInput[]
  disconnect?: TaskWhereUniqueInput[]
  update?: TaskUpdateWithWhereUniqueWithoutSubprojectInput[]
  upsert?: TaskUpsertWithWhereUniqueWithoutSubprojectInput[]
  deleteMany?: TaskScalarWhereInput[]
  updateMany?: TaskUpdateManyWithWhereNestedInput[]
}
export type TaskUpdateManyWithoutSubprojectInputInputObject =
  | Extract<keyof TaskUpdateManyWithoutSubprojectInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TaskUpdateWithWhereUniqueWithoutSubprojectInput {
  where?: TaskWhereUniqueInput
  data?: TaskUpdateWithoutSubprojectDataInput
}
export type TaskUpdateWithWhereUniqueWithoutSubprojectInputInputObject =
  | Extract<keyof TaskUpdateWithWhereUniqueWithoutSubprojectInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TaskUpdateWithoutSubprojectDataInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  timelogs?: TimelogUpdateManyWithoutTaskInput | null
  tags?: TagUpdateManyWithoutTasksInput | null
}
export type TaskUpdateWithoutSubprojectDataInputInputObject =
  | Extract<keyof TaskUpdateWithoutSubprojectDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface TimelogUpdateManyWithoutTaskInput {
  create?: TimelogCreateWithoutTaskInput[]
  delete?: TimelogWhereUniqueInput[]
  connect?: TimelogWhereUniqueInput[]
  set?: TimelogWhereUniqueInput[]
  disconnect?: TimelogWhereUniqueInput[]
  update?: TimelogUpdateWithWhereUniqueWithoutTaskInput[]
  upsert?: TimelogUpsertWithWhereUniqueWithoutTaskInput[]
  deleteMany?: TimelogScalarWhereInput[]
  updateMany?: TimelogUpdateManyWithWhereNestedInput[]
}
export type TimelogUpdateManyWithoutTaskInputInputObject =
  | Extract<keyof TimelogUpdateManyWithoutTaskInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TimelogUpdateWithWhereUniqueWithoutTaskInput {
  where?: TimelogWhereUniqueInput
  data?: TimelogUpdateWithoutTaskDataInput
}
export type TimelogUpdateWithWhereUniqueWithoutTaskInputInputObject =
  | Extract<keyof TimelogUpdateWithWhereUniqueWithoutTaskInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TimelogUpdateWithoutTaskDataInput {
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
}
export type TimelogUpdateWithoutTaskDataInputInputObject =
  | Extract<keyof TimelogUpdateWithoutTaskDataInput, string>
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface TimelogUpsertWithWhereUniqueWithoutTaskInput {
  where?: TimelogWhereUniqueInput
  update?: TimelogUpdateWithoutTaskDataInput
  create?: TimelogCreateWithoutTaskInput
}
export type TimelogUpsertWithWhereUniqueWithoutTaskInputInputObject =
  | Extract<keyof TimelogUpsertWithWhereUniqueWithoutTaskInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TimelogScalarWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  startDate?: string | null
  startDate_not?: string | null
  startDate_in?: string[]
  startDate_not_in?: string[]
  startDate_lt?: string | null
  startDate_lte?: string | null
  startDate_gt?: string | null
  startDate_gte?: string | null
  finishDate?: string | null
  finishDate_not?: string | null
  finishDate_in?: string[]
  finishDate_not_in?: string[]
  finishDate_lt?: string | null
  finishDate_lte?: string | null
  finishDate_gt?: string | null
  finishDate_gte?: string | null
  description?: string | null
  description_not?: string | null
  description_in?: string[]
  description_not_in?: string[]
  description_lt?: string | null
  description_lte?: string | null
  description_gt?: string | null
  description_gte?: string | null
  description_contains?: string | null
  description_not_contains?: string | null
  description_starts_with?: string | null
  description_not_starts_with?: string | null
  description_ends_with?: string | null
  description_not_ends_with?: string | null
  AND?: TimelogScalarWhereInput[]
  OR?: TimelogScalarWhereInput[]
  NOT?: TimelogScalarWhereInput[]
}
export type TimelogScalarWhereInputInputObject =
  | Extract<keyof TimelogScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'startDate', alias?: string  } 
  | { name: 'startDate_not', alias?: string  } 
  | { name: 'startDate_in', alias?: string  } 
  | { name: 'startDate_not_in', alias?: string  } 
  | { name: 'startDate_lt', alias?: string  } 
  | { name: 'startDate_lte', alias?: string  } 
  | { name: 'startDate_gt', alias?: string  } 
  | { name: 'startDate_gte', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'finishDate_not', alias?: string  } 
  | { name: 'finishDate_in', alias?: string  } 
  | { name: 'finishDate_not_in', alias?: string  } 
  | { name: 'finishDate_lt', alias?: string  } 
  | { name: 'finishDate_lte', alias?: string  } 
  | { name: 'finishDate_gt', alias?: string  } 
  | { name: 'finishDate_gte', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'description_not', alias?: string  } 
  | { name: 'description_in', alias?: string  } 
  | { name: 'description_not_in', alias?: string  } 
  | { name: 'description_lt', alias?: string  } 
  | { name: 'description_lte', alias?: string  } 
  | { name: 'description_gt', alias?: string  } 
  | { name: 'description_gte', alias?: string  } 
  | { name: 'description_contains', alias?: string  } 
  | { name: 'description_not_contains', alias?: string  } 
  | { name: 'description_starts_with', alias?: string  } 
  | { name: 'description_not_starts_with', alias?: string  } 
  | { name: 'description_ends_with', alias?: string  } 
  | { name: 'description_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TimelogUpdateManyWithWhereNestedInput {
  where?: TimelogScalarWhereInput
  data?: TimelogUpdateManyDataInput
}
export type TimelogUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TimelogUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TimelogUpdateManyDataInput {
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
}
export type TimelogUpdateManyDataInputInputObject =
  | Extract<keyof TimelogUpdateManyDataInput, string>
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface TagUpdateManyWithoutTasksInput {
  create?: TagCreateWithoutTasksInput[]
  delete?: TagWhereUniqueInput[]
  connect?: TagWhereUniqueInput[]
  set?: TagWhereUniqueInput[]
  disconnect?: TagWhereUniqueInput[]
  update?: TagUpdateWithWhereUniqueWithoutTasksInput[]
  upsert?: TagUpsertWithWhereUniqueWithoutTasksInput[]
  deleteMany?: TagScalarWhereInput[]
  updateMany?: TagUpdateManyWithWhereNestedInput[]
}
export type TagUpdateManyWithoutTasksInputInputObject =
  | Extract<keyof TagUpdateManyWithoutTasksInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TagUpdateWithWhereUniqueWithoutTasksInput {
  where?: TagWhereUniqueInput
  data?: TagUpdateWithoutTasksDataInput
}
export type TagUpdateWithWhereUniqueWithoutTasksInputInputObject =
  | Extract<keyof TagUpdateWithWhereUniqueWithoutTasksInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TagUpdateWithoutTasksDataInput {
  name?: string | null
}
export type TagUpdateWithoutTasksDataInputInputObject =
  | Extract<keyof TagUpdateWithoutTasksDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface TagUpsertWithWhereUniqueWithoutTasksInput {
  where?: TagWhereUniqueInput
  update?: TagUpdateWithoutTasksDataInput
  create?: TagCreateWithoutTasksInput
}
export type TagUpsertWithWhereUniqueWithoutTasksInputInputObject =
  | Extract<keyof TagUpsertWithWhereUniqueWithoutTasksInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TagScalarWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  AND?: TagScalarWhereInput[]
  OR?: TagScalarWhereInput[]
  NOT?: TagScalarWhereInput[]
}
export type TagScalarWhereInputInputObject =
  | Extract<keyof TagScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TagUpdateManyWithWhereNestedInput {
  where?: TagScalarWhereInput
  data?: TagUpdateManyDataInput
}
export type TagUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TagUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TagUpdateManyDataInput {
  name?: string | null
}
export type TagUpdateManyDataInputInputObject =
  | Extract<keyof TagUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface TaskUpsertWithWhereUniqueWithoutSubprojectInput {
  where?: TaskWhereUniqueInput
  update?: TaskUpdateWithoutSubprojectDataInput
  create?: TaskCreateWithoutSubprojectInput
}
export type TaskUpsertWithWhereUniqueWithoutSubprojectInputInputObject =
  | Extract<keyof TaskUpsertWithWhereUniqueWithoutSubprojectInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TaskScalarWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  priority?: string | null
  priority_not?: string | null
  priority_in?: string[]
  priority_not_in?: string[]
  priority_lt?: string | null
  priority_lte?: string | null
  priority_gt?: string | null
  priority_gte?: string | null
  priority_contains?: string | null
  priority_not_contains?: string | null
  priority_starts_with?: string | null
  priority_not_starts_with?: string | null
  priority_ends_with?: string | null
  priority_not_ends_with?: string | null
  comments?: string | null
  comments_not?: string | null
  comments_in?: string[]
  comments_not_in?: string[]
  comments_lt?: string | null
  comments_lte?: string | null
  comments_gt?: string | null
  comments_gte?: string | null
  comments_contains?: string | null
  comments_not_contains?: string | null
  comments_starts_with?: string | null
  comments_not_starts_with?: string | null
  comments_ends_with?: string | null
  comments_not_ends_with?: string | null
  repeat?: number | null
  repeat_not?: number | null
  repeat_in?: number[]
  repeat_not_in?: number[]
  repeat_lt?: number | null
  repeat_lte?: number | null
  repeat_gt?: number | null
  repeat_gte?: number | null
  estimateTime?: string | null
  estimateTime_not?: string | null
  estimateTime_in?: string[]
  estimateTime_not_in?: string[]
  estimateTime_lt?: string | null
  estimateTime_lte?: string | null
  estimateTime_gt?: string | null
  estimateTime_gte?: string | null
  estimateTime_contains?: string | null
  estimateTime_not_contains?: string | null
  estimateTime_starts_with?: string | null
  estimateTime_not_starts_with?: string | null
  estimateTime_ends_with?: string | null
  estimateTime_not_ends_with?: string | null
  plannedTime?: string | null
  plannedTime_not?: string | null
  plannedTime_in?: string[]
  plannedTime_not_in?: string[]
  plannedTime_lt?: string | null
  plannedTime_lte?: string | null
  plannedTime_gt?: string | null
  plannedTime_gte?: string | null
  plannedTime_contains?: string | null
  plannedTime_not_contains?: string | null
  plannedTime_starts_with?: string | null
  plannedTime_not_starts_with?: string | null
  plannedTime_ends_with?: string | null
  plannedTime_not_ends_with?: string | null
  plannedDate?: string | null
  plannedDate_not?: string | null
  plannedDate_in?: string[]
  plannedDate_not_in?: string[]
  plannedDate_lt?: string | null
  plannedDate_lte?: string | null
  plannedDate_gt?: string | null
  plannedDate_gte?: string | null
  plannedDate_contains?: string | null
  plannedDate_not_contains?: string | null
  plannedDate_starts_with?: string | null
  plannedDate_not_starts_with?: string | null
  plannedDate_ends_with?: string | null
  plannedDate_not_ends_with?: string | null
  finishDate?: string | null
  finishDate_not?: string | null
  finishDate_in?: string[]
  finishDate_not_in?: string[]
  finishDate_lt?: string | null
  finishDate_lte?: string | null
  finishDate_gt?: string | null
  finishDate_gte?: string | null
  finishDate_contains?: string | null
  finishDate_not_contains?: string | null
  finishDate_starts_with?: string | null
  finishDate_not_starts_with?: string | null
  finishDate_ends_with?: string | null
  finishDate_not_ends_with?: string | null
  deadlineDate?: string | null
  deadlineDate_not?: string | null
  deadlineDate_in?: string[]
  deadlineDate_not_in?: string[]
  deadlineDate_lt?: string | null
  deadlineDate_lte?: string | null
  deadlineDate_gt?: string | null
  deadlineDate_gte?: string | null
  deadlineDate_contains?: string | null
  deadlineDate_not_contains?: string | null
  deadlineDate_starts_with?: string | null
  deadlineDate_not_starts_with?: string | null
  deadlineDate_ends_with?: string | null
  deadlineDate_not_ends_with?: string | null
  completed?: boolean | null
  completed_not?: boolean | null
  AND?: TaskScalarWhereInput[]
  OR?: TaskScalarWhereInput[]
  NOT?: TaskScalarWhereInput[]
}
export type TaskScalarWhereInputInputObject =
  | Extract<keyof TaskScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'priority_not', alias?: string  } 
  | { name: 'priority_in', alias?: string  } 
  | { name: 'priority_not_in', alias?: string  } 
  | { name: 'priority_lt', alias?: string  } 
  | { name: 'priority_lte', alias?: string  } 
  | { name: 'priority_gt', alias?: string  } 
  | { name: 'priority_gte', alias?: string  } 
  | { name: 'priority_contains', alias?: string  } 
  | { name: 'priority_not_contains', alias?: string  } 
  | { name: 'priority_starts_with', alias?: string  } 
  | { name: 'priority_not_starts_with', alias?: string  } 
  | { name: 'priority_ends_with', alias?: string  } 
  | { name: 'priority_not_ends_with', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'comments_not', alias?: string  } 
  | { name: 'comments_in', alias?: string  } 
  | { name: 'comments_not_in', alias?: string  } 
  | { name: 'comments_lt', alias?: string  } 
  | { name: 'comments_lte', alias?: string  } 
  | { name: 'comments_gt', alias?: string  } 
  | { name: 'comments_gte', alias?: string  } 
  | { name: 'comments_contains', alias?: string  } 
  | { name: 'comments_not_contains', alias?: string  } 
  | { name: 'comments_starts_with', alias?: string  } 
  | { name: 'comments_not_starts_with', alias?: string  } 
  | { name: 'comments_ends_with', alias?: string  } 
  | { name: 'comments_not_ends_with', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'repeat_not', alias?: string  } 
  | { name: 'repeat_in', alias?: string  } 
  | { name: 'repeat_not_in', alias?: string  } 
  | { name: 'repeat_lt', alias?: string  } 
  | { name: 'repeat_lte', alias?: string  } 
  | { name: 'repeat_gt', alias?: string  } 
  | { name: 'repeat_gte', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'estimateTime_not', alias?: string  } 
  | { name: 'estimateTime_in', alias?: string  } 
  | { name: 'estimateTime_not_in', alias?: string  } 
  | { name: 'estimateTime_lt', alias?: string  } 
  | { name: 'estimateTime_lte', alias?: string  } 
  | { name: 'estimateTime_gt', alias?: string  } 
  | { name: 'estimateTime_gte', alias?: string  } 
  | { name: 'estimateTime_contains', alias?: string  } 
  | { name: 'estimateTime_not_contains', alias?: string  } 
  | { name: 'estimateTime_starts_with', alias?: string  } 
  | { name: 'estimateTime_not_starts_with', alias?: string  } 
  | { name: 'estimateTime_ends_with', alias?: string  } 
  | { name: 'estimateTime_not_ends_with', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedTime_not', alias?: string  } 
  | { name: 'plannedTime_in', alias?: string  } 
  | { name: 'plannedTime_not_in', alias?: string  } 
  | { name: 'plannedTime_lt', alias?: string  } 
  | { name: 'plannedTime_lte', alias?: string  } 
  | { name: 'plannedTime_gt', alias?: string  } 
  | { name: 'plannedTime_gte', alias?: string  } 
  | { name: 'plannedTime_contains', alias?: string  } 
  | { name: 'plannedTime_not_contains', alias?: string  } 
  | { name: 'plannedTime_starts_with', alias?: string  } 
  | { name: 'plannedTime_not_starts_with', alias?: string  } 
  | { name: 'plannedTime_ends_with', alias?: string  } 
  | { name: 'plannedTime_not_ends_with', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'plannedDate_not', alias?: string  } 
  | { name: 'plannedDate_in', alias?: string  } 
  | { name: 'plannedDate_not_in', alias?: string  } 
  | { name: 'plannedDate_lt', alias?: string  } 
  | { name: 'plannedDate_lte', alias?: string  } 
  | { name: 'plannedDate_gt', alias?: string  } 
  | { name: 'plannedDate_gte', alias?: string  } 
  | { name: 'plannedDate_contains', alias?: string  } 
  | { name: 'plannedDate_not_contains', alias?: string  } 
  | { name: 'plannedDate_starts_with', alias?: string  } 
  | { name: 'plannedDate_not_starts_with', alias?: string  } 
  | { name: 'plannedDate_ends_with', alias?: string  } 
  | { name: 'plannedDate_not_ends_with', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'finishDate_not', alias?: string  } 
  | { name: 'finishDate_in', alias?: string  } 
  | { name: 'finishDate_not_in', alias?: string  } 
  | { name: 'finishDate_lt', alias?: string  } 
  | { name: 'finishDate_lte', alias?: string  } 
  | { name: 'finishDate_gt', alias?: string  } 
  | { name: 'finishDate_gte', alias?: string  } 
  | { name: 'finishDate_contains', alias?: string  } 
  | { name: 'finishDate_not_contains', alias?: string  } 
  | { name: 'finishDate_starts_with', alias?: string  } 
  | { name: 'finishDate_not_starts_with', alias?: string  } 
  | { name: 'finishDate_ends_with', alias?: string  } 
  | { name: 'finishDate_not_ends_with', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'deadlineDate_not', alias?: string  } 
  | { name: 'deadlineDate_in', alias?: string  } 
  | { name: 'deadlineDate_not_in', alias?: string  } 
  | { name: 'deadlineDate_lt', alias?: string  } 
  | { name: 'deadlineDate_lte', alias?: string  } 
  | { name: 'deadlineDate_gt', alias?: string  } 
  | { name: 'deadlineDate_gte', alias?: string  } 
  | { name: 'deadlineDate_contains', alias?: string  } 
  | { name: 'deadlineDate_not_contains', alias?: string  } 
  | { name: 'deadlineDate_starts_with', alias?: string  } 
  | { name: 'deadlineDate_not_starts_with', alias?: string  } 
  | { name: 'deadlineDate_ends_with', alias?: string  } 
  | { name: 'deadlineDate_not_ends_with', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'completed_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TaskUpdateManyWithWhereNestedInput {
  where?: TaskScalarWhereInput
  data?: TaskUpdateManyDataInput
}
export type TaskUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof TaskUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TaskUpdateManyDataInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
}
export type TaskUpdateManyDataInputInputObject =
  | Extract<keyof TaskUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  
export interface SubprojectUpsertWithWhereUniqueWithoutProjectInput {
  where?: SubprojectWhereUniqueInput
  update?: SubprojectUpdateWithoutProjectDataInput
  create?: SubprojectCreateWithoutProjectInput
}
export type SubprojectUpsertWithWhereUniqueWithoutProjectInputInputObject =
  | Extract<keyof SubprojectUpsertWithWhereUniqueWithoutProjectInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface SubprojectScalarWhereInput {
  id?: number | null
  id_not?: number | null
  id_in?: number[]
  id_not_in?: number[]
  id_lt?: number | null
  id_lte?: number | null
  id_gt?: number | null
  id_gte?: number | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  AND?: SubprojectScalarWhereInput[]
  OR?: SubprojectScalarWhereInput[]
  NOT?: SubprojectScalarWhereInput[]
}
export type SubprojectScalarWhereInputInputObject =
  | Extract<keyof SubprojectScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SubprojectUpdateManyWithWhereNestedInput {
  where?: SubprojectScalarWhereInput
  data?: SubprojectUpdateManyDataInput
}
export type SubprojectUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof SubprojectUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface SubprojectUpdateManyDataInput {
  name?: string | null
}
export type SubprojectUpdateManyDataInputInputObject =
  | Extract<keyof SubprojectUpdateManyDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface ProjectUpdateManyMutationInput {
  name?: string | null
}
export type ProjectUpdateManyMutationInputInputObject =
  | Extract<keyof ProjectUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface SubprojectCreateInput {
  id?: number | null
  name?: string
  project?: ProjectCreateOneWithoutSubprojectsInput
  tasks?: TaskCreateManyWithoutSubprojectInput | null
}
export type SubprojectCreateInputInputObject =
  | Extract<keyof SubprojectCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'project', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface ProjectCreateOneWithoutSubprojectsInput {
  create?: ProjectCreateWithoutSubprojectsInput | null
  connect?: ProjectWhereUniqueInput | null
}
export type ProjectCreateOneWithoutSubprojectsInputInputObject =
  | Extract<keyof ProjectCreateOneWithoutSubprojectsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface ProjectCreateWithoutSubprojectsInput {
  id?: number | null
  name?: string
}
export type ProjectCreateWithoutSubprojectsInputInputObject =
  | Extract<keyof ProjectCreateWithoutSubprojectsInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface SubprojectUpdateInput {
  name?: string | null
  project?: ProjectUpdateOneRequiredWithoutSubprojectsInput | null
  tasks?: TaskUpdateManyWithoutSubprojectInput | null
}
export type SubprojectUpdateInputInputObject =
  | Extract<keyof SubprojectUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'project', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface ProjectUpdateOneRequiredWithoutSubprojectsInput {
  create?: ProjectCreateWithoutSubprojectsInput | null
  update?: ProjectUpdateWithoutSubprojectsDataInput | null
  upsert?: ProjectUpsertWithoutSubprojectsInput | null
  connect?: ProjectWhereUniqueInput | null
}
export type ProjectUpdateOneRequiredWithoutSubprojectsInputInputObject =
  | Extract<keyof ProjectUpdateOneRequiredWithoutSubprojectsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface ProjectUpdateWithoutSubprojectsDataInput {
  name?: string | null
}
export type ProjectUpdateWithoutSubprojectsDataInputInputObject =
  | Extract<keyof ProjectUpdateWithoutSubprojectsDataInput, string>
  | { name: 'name', alias?: string  } 
  
export interface ProjectUpsertWithoutSubprojectsInput {
  update?: ProjectUpdateWithoutSubprojectsDataInput
  create?: ProjectCreateWithoutSubprojectsInput
}
export type ProjectUpsertWithoutSubprojectsInputInputObject =
  | Extract<keyof ProjectUpsertWithoutSubprojectsInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface SubprojectUpdateManyMutationInput {
  name?: string | null
}
export type SubprojectUpdateManyMutationInputInputObject =
  | Extract<keyof SubprojectUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface TaskCreateInput {
  id?: number | null
  name?: string
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectCreateOneWithoutTasksInput | null
  timelogs?: TimelogCreateManyWithoutTaskInput | null
  tags?: TagCreateManyWithoutTasksInput | null
}
export type TaskCreateInputInputObject =
  | Extract<keyof TaskCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface SubprojectCreateOneWithoutTasksInput {
  create?: SubprojectCreateWithoutTasksInput | null
  connect?: SubprojectWhereUniqueInput | null
}
export type SubprojectCreateOneWithoutTasksInputInputObject =
  | Extract<keyof SubprojectCreateOneWithoutTasksInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SubprojectCreateWithoutTasksInput {
  id?: number | null
  name?: string
  project?: ProjectCreateOneWithoutSubprojectsInput
}
export type SubprojectCreateWithoutTasksInputInputObject =
  | Extract<keyof SubprojectCreateWithoutTasksInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'project', alias?: string  } 
  
export interface TaskUpdateInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectUpdateOneWithoutTasksInput | null
  timelogs?: TimelogUpdateManyWithoutTaskInput | null
  tags?: TagUpdateManyWithoutTasksInput | null
}
export type TaskUpdateInputInputObject =
  | Extract<keyof TaskUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface SubprojectUpdateOneWithoutTasksInput {
  create?: SubprojectCreateWithoutTasksInput | null
  update?: SubprojectUpdateWithoutTasksDataInput | null
  upsert?: SubprojectUpsertWithoutTasksInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: SubprojectWhereUniqueInput | null
}
export type SubprojectUpdateOneWithoutTasksInputInputObject =
  | Extract<keyof SubprojectUpdateOneWithoutTasksInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface SubprojectUpdateWithoutTasksDataInput {
  name?: string | null
  project?: ProjectUpdateOneRequiredWithoutSubprojectsInput | null
}
export type SubprojectUpdateWithoutTasksDataInputInputObject =
  | Extract<keyof SubprojectUpdateWithoutTasksDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'project', alias?: string  } 
  
export interface SubprojectUpsertWithoutTasksInput {
  update?: SubprojectUpdateWithoutTasksDataInput
  create?: SubprojectCreateWithoutTasksInput
}
export type SubprojectUpsertWithoutTasksInputInputObject =
  | Extract<keyof SubprojectUpsertWithoutTasksInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TaskUpdateManyMutationInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
}
export type TaskUpdateManyMutationInputInputObject =
  | Extract<keyof TaskUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  
export interface TimelogCreateInput {
  id?: number | null
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
  task?: TaskCreateOneWithoutTimelogsInput
}
export type TimelogCreateInputInputObject =
  | Extract<keyof TimelogCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'task', alias?: string  } 
  
export interface TaskCreateOneWithoutTimelogsInput {
  create?: TaskCreateWithoutTimelogsInput | null
  connect?: TaskWhereUniqueInput | null
}
export type TaskCreateOneWithoutTimelogsInputInputObject =
  | Extract<keyof TaskCreateOneWithoutTimelogsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TaskCreateWithoutTimelogsInput {
  id?: number | null
  name?: string
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectCreateOneWithoutTasksInput | null
  tags?: TagCreateManyWithoutTasksInput | null
}
export type TaskCreateWithoutTimelogsInputInputObject =
  | Extract<keyof TaskCreateWithoutTimelogsInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface TimelogUpdateInput {
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
  task?: TaskUpdateOneRequiredWithoutTimelogsInput | null
}
export type TimelogUpdateInputInputObject =
  | Extract<keyof TimelogUpdateInput, string>
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  | { name: 'task', alias?: string  } 
  
export interface TaskUpdateOneRequiredWithoutTimelogsInput {
  create?: TaskCreateWithoutTimelogsInput | null
  update?: TaskUpdateWithoutTimelogsDataInput | null
  upsert?: TaskUpsertWithoutTimelogsInput | null
  connect?: TaskWhereUniqueInput | null
}
export type TaskUpdateOneRequiredWithoutTimelogsInputInputObject =
  | Extract<keyof TaskUpdateOneRequiredWithoutTimelogsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TaskUpdateWithoutTimelogsDataInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectUpdateOneWithoutTasksInput | null
  tags?: TagUpdateManyWithoutTasksInput | null
}
export type TaskUpdateWithoutTimelogsDataInputInputObject =
  | Extract<keyof TaskUpdateWithoutTimelogsDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'tags', alias?: string  } 
  
export interface TaskUpsertWithoutTimelogsInput {
  update?: TaskUpdateWithoutTimelogsDataInput
  create?: TaskCreateWithoutTimelogsInput
}
export type TaskUpsertWithoutTimelogsInputInputObject =
  | Extract<keyof TaskUpsertWithoutTimelogsInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TimelogUpdateManyMutationInput {
  startDate?: string | null
  finishDate?: string | null
  description?: string | null
}
export type TimelogUpdateManyMutationInputInputObject =
  | Extract<keyof TimelogUpdateManyMutationInput, string>
  | { name: 'startDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'description', alias?: string  } 
  
export interface TagCreateInput {
  id?: number | null
  name?: string
  tasks?: TaskCreateManyWithoutTagsInput | null
}
export type TagCreateInputInputObject =
  | Extract<keyof TagCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface TaskCreateManyWithoutTagsInput {
  create?: TaskCreateWithoutTagsInput[]
  connect?: TaskWhereUniqueInput[]
}
export type TaskCreateManyWithoutTagsInputInputObject =
  | Extract<keyof TaskCreateManyWithoutTagsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface TaskCreateWithoutTagsInput {
  id?: number | null
  name?: string
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectCreateOneWithoutTasksInput | null
  timelogs?: TimelogCreateManyWithoutTaskInput | null
}
export type TaskCreateWithoutTagsInputInputObject =
  | Extract<keyof TaskCreateWithoutTagsInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  
export interface TagUpdateInput {
  name?: string | null
  tasks?: TaskUpdateManyWithoutTagsInput | null
}
export type TagUpdateInputInputObject =
  | Extract<keyof TagUpdateInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'tasks', alias?: string  } 
  
export interface TaskUpdateManyWithoutTagsInput {
  create?: TaskCreateWithoutTagsInput[]
  delete?: TaskWhereUniqueInput[]
  connect?: TaskWhereUniqueInput[]
  set?: TaskWhereUniqueInput[]
  disconnect?: TaskWhereUniqueInput[]
  update?: TaskUpdateWithWhereUniqueWithoutTagsInput[]
  upsert?: TaskUpsertWithWhereUniqueWithoutTagsInput[]
  deleteMany?: TaskScalarWhereInput[]
  updateMany?: TaskUpdateManyWithWhereNestedInput[]
}
export type TaskUpdateManyWithoutTagsInputInputObject =
  | Extract<keyof TaskUpdateManyWithoutTagsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface TaskUpdateWithWhereUniqueWithoutTagsInput {
  where?: TaskWhereUniqueInput
  data?: TaskUpdateWithoutTagsDataInput
}
export type TaskUpdateWithWhereUniqueWithoutTagsInputInputObject =
  | Extract<keyof TaskUpdateWithWhereUniqueWithoutTagsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface TaskUpdateWithoutTagsDataInput {
  name?: string | null
  priority?: string | null
  comments?: string | null
  repeat?: number | null
  estimateTime?: string | null
  plannedTime?: string | null
  plannedDate?: string | null
  finishDate?: string | null
  deadlineDate?: string | null
  completed?: boolean | null
  subproject?: SubprojectUpdateOneWithoutTasksInput | null
  timelogs?: TimelogUpdateManyWithoutTaskInput | null
}
export type TaskUpdateWithoutTagsDataInputInputObject =
  | Extract<keyof TaskUpdateWithoutTagsDataInput, string>
  | { name: 'name', alias?: string  } 
  | { name: 'priority', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'repeat', alias?: string  } 
  | { name: 'estimateTime', alias?: string  } 
  | { name: 'plannedTime', alias?: string  } 
  | { name: 'plannedDate', alias?: string  } 
  | { name: 'finishDate', alias?: string  } 
  | { name: 'deadlineDate', alias?: string  } 
  | { name: 'completed', alias?: string  } 
  | { name: 'subproject', alias?: string  } 
  | { name: 'timelogs', alias?: string  } 
  
export interface TaskUpsertWithWhereUniqueWithoutTagsInput {
  where?: TaskWhereUniqueInput
  update?: TaskUpdateWithoutTagsDataInput
  create?: TaskCreateWithoutTagsInput
}
export type TaskUpsertWithWhereUniqueWithoutTagsInputInputObject =
  | Extract<keyof TaskUpsertWithWhereUniqueWithoutTagsInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface TagUpdateManyMutationInput {
  name?: string | null
}
export type TagUpdateManyMutationInputInputObject =
  | Extract<keyof TagUpdateManyMutationInput, string>
  | { name: 'name', alias?: string  } 
  
export interface ProjectSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: ProjectWhereInput | null
  AND?: ProjectSubscriptionWhereInput[]
  OR?: ProjectSubscriptionWhereInput[]
  NOT?: ProjectSubscriptionWhereInput[]
}
export type ProjectSubscriptionWhereInputInputObject =
  | Extract<keyof ProjectSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface SubprojectSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: SubprojectWhereInput | null
  AND?: SubprojectSubscriptionWhereInput[]
  OR?: SubprojectSubscriptionWhereInput[]
  NOT?: SubprojectSubscriptionWhereInput[]
}
export type SubprojectSubscriptionWhereInputInputObject =
  | Extract<keyof SubprojectSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TaskSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TaskWhereInput | null
  AND?: TaskSubscriptionWhereInput[]
  OR?: TaskSubscriptionWhereInput[]
  NOT?: TaskSubscriptionWhereInput[]
}
export type TaskSubscriptionWhereInputInputObject =
  | Extract<keyof TaskSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TimelogSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TimelogWhereInput | null
  AND?: TimelogSubscriptionWhereInput[]
  OR?: TimelogSubscriptionWhereInput[]
  NOT?: TimelogSubscriptionWhereInput[]
}
export type TimelogSubscriptionWhereInputInputObject =
  | Extract<keyof TimelogSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface TagSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: TagWhereInput | null
  AND?: TagSubscriptionWhereInput[]
  OR?: TagSubscriptionWhereInput[]
  NOT?: TagSubscriptionWhereInput[]
}
export type TagSubscriptionWhereInputInputObject =
  | Extract<keyof TagSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type SubprojectOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type TaskOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'priority_ASC'
  | 'priority_DESC'
  | 'comments_ASC'
  | 'comments_DESC'
  | 'repeat_ASC'
  | 'repeat_DESC'
  | 'estimateTime_ASC'
  | 'estimateTime_DESC'
  | 'plannedTime_ASC'
  | 'plannedTime_DESC'
  | 'plannedDate_ASC'
  | 'plannedDate_DESC'
  | 'finishDate_ASC'
  | 'finishDate_DESC'
  | 'deadlineDate_ASC'
  | 'deadlineDate_DESC'
  | 'completed_ASC'
  | 'completed_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type TimelogOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'startDate_ASC'
  | 'startDate_DESC'
  | 'finishDate_ASC'
  | 'finishDate_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type TagOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type ProjectOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  