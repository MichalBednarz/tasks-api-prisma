### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type AggregateProject {
  count: Int!
}

type AggregateSubproject {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateTimelog {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  cloneTask(where: TaskWhereUniqueInput): Task!
  completeTask(where: TaskWhereUniqueInput!): Task!
  createProject(data: ProjectCreateInput!): Project!
  createSubproject(data: SubprojectCreateInput!): Subproject!
  createTask(data: TaskCreateInput!): Task!
  createTimelog(data: TimelogCreateInput!): Timelog!
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  deleteManySubprojects(where: SubprojectWhereInput): BatchPayload!
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  deleteManyTimelogs(where: TimelogWhereInput): BatchPayload!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteSubproject(where: SubprojectWhereUniqueInput!): Subproject
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteTimelog(where: TimelogWhereUniqueInput!): Timelog
  startTimelog(data: TimelogCreateInput): Timelog!
  stopTimelog(where: TimelogWhereUniqueInput!): Timelog!
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  updateManySubprojects(data: SubprojectUpdateManyMutationInput!, where: SubprojectWhereInput): BatchPayload!
  updateManyTasks(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): BatchPayload!
  updateManyTimelogs(data: TimelogUpdateManyMutationInput!, where: TimelogWhereInput): BatchPayload!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateSubproject(data: SubprojectUpdateInput!, where: SubprojectWhereUniqueInput!): Subproject
  updateTask: Task!
  updateTimelog(data: TimelogUpdateInput!, where: TimelogWhereUniqueInput!): Timelog
  upsertProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertSubproject(create: SubprojectCreateInput!, update: SubprojectUpdateInput!, where: SubprojectWhereUniqueInput!): Subproject!
  upsertTask(create: TaskCreateInput!, update: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task!
  upsertTimelog(create: TimelogCreateInput!, update: TimelogUpdateInput!, where: TimelogWhereUniqueInput!): Timelog!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Project {
  estimateTime: String
  id: Int!
  name: String!
  statusTime: String
  subprojects(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): [Subproject!]
}

type ProjectConnection {
  aggregate: AggregateProject!
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}

input ProjectCreateInput {
  id: Int
  name: String!
  subprojects: SubprojectCreateManyWithoutProjectInput
}

input ProjectCreateOneWithoutSubprojectsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutSubprojectsInput
}

input ProjectCreateWithoutSubprojectsInput {
  id: Int
  name: String!
}

type ProjectEdge {
  cursor: String!
  node: Project!
}

enum ProjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectUpdateInput {
  name: String
  subprojects: SubprojectUpdateManyWithoutProjectInput
}

input ProjectUpdateManyMutationInput {
  name: String
}

input ProjectUpdateOneRequiredWithoutSubprojectsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutSubprojectsInput
  update: ProjectUpdateWithoutSubprojectsDataInput
  upsert: ProjectUpsertWithoutSubprojectsInput
}

input ProjectUpdateWithoutSubprojectsDataInput {
  name: String
}

input ProjectUpsertWithoutSubprojectsInput {
  create: ProjectCreateWithoutSubprojectsInput!
  update: ProjectUpdateWithoutSubprojectsDataInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  subprojects_every: SubprojectWhereInput
  subprojects_none: SubprojectWhereInput
  subprojects_some: SubprojectWhereInput
}

input ProjectWhereUniqueInput {
  id: Int
  name: String
}

type Query {
  activeTimelog: Timelog
  project(where: ProjectWhereUniqueInput!): Project
  projects(after: String, before: String, first: Int, last: Int, orderBy: ProjectOrderByInput, skip: Int, where: ProjectWhereInput): [Project!]!
  projectsConnection(after: String, before: String, first: Int, last: Int, orderBy: ProjectOrderByInput, skip: Int, where: ProjectWhereInput): ProjectConnection!
  subproject(where: SubprojectWhereUniqueInput!): Subproject
  subprojects(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): [Subproject!]!
  subprojectsConnection(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): SubprojectConnection!
  task(where: TaskWhereUniqueInput!): Task
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]!
  tasksConnection(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): TaskConnection!
  timelog(where: TimelogWhereUniqueInput!): Timelog
  timelogs(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): [Timelog!]!
  timelogsConnection(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): TimelogConnection!
}

type Subproject {
  estimateTime: String
  id: Int!
  name: String!
  project: Project!
  statusTime: String
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]
}

type SubprojectConnection {
  aggregate: AggregateSubproject!
  edges: [SubprojectEdge!]!
  pageInfo: PageInfo!
}

input SubprojectCreateInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateManyWithoutProjectInput {
  connect: [SubprojectWhereUniqueInput!]
  create: [SubprojectCreateWithoutProjectInput!]
}

input SubprojectCreateOneWithoutTasksInput {
  connect: SubprojectWhereUniqueInput
  create: SubprojectCreateWithoutTasksInput
}

input SubprojectCreateWithoutProjectInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateWithoutTasksInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
}

type SubprojectEdge {
  cursor: String!
  node: Subproject!
}

enum SubprojectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SubprojectScalarWhereInput {
  AND: [SubprojectScalarWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [SubprojectScalarWhereInput!]
  OR: [SubprojectScalarWhereInput!]
}

input SubprojectUpdateInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateManyDataInput {
  name: String
}

input SubprojectUpdateManyMutationInput {
  name: String
}

input SubprojectUpdateManyWithoutProjectInput {
  connect: [SubprojectWhereUniqueInput!]
  create: [SubprojectCreateWithoutProjectInput!]
  delete: [SubprojectWhereUniqueInput!]
  deleteMany: [SubprojectScalarWhereInput!]
  disconnect: [SubprojectWhereUniqueInput!]
  set: [SubprojectWhereUniqueInput!]
  update: [SubprojectUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [SubprojectUpdateManyWithWhereNestedInput!]
  upsert: [SubprojectUpsertWithWhereUniqueWithoutProjectInput!]
}

input SubprojectUpdateManyWithWhereNestedInput {
  data: SubprojectUpdateManyDataInput!
  where: SubprojectScalarWhereInput!
}

input SubprojectUpdateOneWithoutTasksInput {
  connect: SubprojectWhereUniqueInput
  create: SubprojectCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: SubprojectUpdateWithoutTasksDataInput
  upsert: SubprojectUpsertWithoutTasksInput
}

input SubprojectUpdateWithoutProjectDataInput {
  name: String
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateWithoutTasksDataInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
}

input SubprojectUpdateWithWhereUniqueWithoutProjectInput {
  data: SubprojectUpdateWithoutProjectDataInput!
  where: SubprojectWhereUniqueInput!
}

input SubprojectUpsertWithoutTasksInput {
  create: SubprojectCreateWithoutTasksInput!
  update: SubprojectUpdateWithoutTasksDataInput!
}

input SubprojectUpsertWithWhereUniqueWithoutProjectInput {
  create: SubprojectCreateWithoutProjectInput!
  update: SubprojectUpdateWithoutProjectDataInput!
  where: SubprojectWhereUniqueInput!
}

input SubprojectWhereInput {
  AND: [SubprojectWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [SubprojectWhereInput!]
  OR: [SubprojectWhereInput!]
  project: ProjectWhereInput
  tasks_every: TaskWhereInput
  tasks_none: TaskWhereInput
  tasks_some: TaskWhereInput
}

input SubprojectWhereUniqueInput {
  id: Int
  name: String
}

type Task {
  comments: String
  completed: Boolean!
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int!
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  project: Project
  repeat: Int
  statusTime: String
  subproject: Subproject
  timelogs(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): [Timelog!]
}

type TaskConnection {
  aggregate: AggregateTask!
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

input TaskCreateInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
}

input TaskCreateManyWithoutSubprojectInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutSubprojectInput!]
}

input TaskCreateOneWithoutTimelogsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTimelogsInput
}

input TaskCreateWithoutSubprojectInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  timelogs: TimelogCreateManyWithoutTaskInput
}

input TaskCreateWithoutTimelogsInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
}

type TaskEdge {
  cursor: String!
  node: Task!
}

enum TaskOrderByInput {
  comments_ASC
  comments_DESC
  completed_ASC
  completed_DESC
  createdAt_ASC
  createdAt_DESC
  deadlineDate_ASC
  deadlineDate_DESC
  estimateTime_ASC
  estimateTime_DESC
  finishDate_ASC
  finishDate_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  plannedDate_ASC
  plannedDate_DESC
  plannedTime_ASC
  plannedTime_DESC
  priority_ASC
  priority_DESC
  repeat_ASC
  repeat_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  comments: String
  comments_contains: String
  comments_ends_with: String
  comments_gt: String
  comments_gte: String
  comments_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_not: String
  comments_not_contains: String
  comments_not_ends_with: String
  comments_not_in: [String!]
  comments_not_starts_with: String
  comments_starts_with: String
  completed: Boolean
  completed_not: Boolean
  deadlineDate: String
  deadlineDate_contains: String
  deadlineDate_ends_with: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_not: String
  deadlineDate_not_contains: String
  deadlineDate_not_ends_with: String
  deadlineDate_not_in: [String!]
  deadlineDate_not_starts_with: String
  deadlineDate_starts_with: String
  estimateTime: String
  estimateTime_contains: String
  estimateTime_ends_with: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_not: String
  estimateTime_not_contains: String
  estimateTime_not_ends_with: String
  estimateTime_not_in: [String!]
  estimateTime_not_starts_with: String
  estimateTime_starts_with: String
  finishDate: String
  finishDate_contains: String
  finishDate_ends_with: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_not: String
  finishDate_not_contains: String
  finishDate_not_ends_with: String
  finishDate_not_in: [String!]
  finishDate_not_starts_with: String
  finishDate_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  plannedDate: String
  plannedDate_contains: String
  plannedDate_ends_with: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_not: String
  plannedDate_not_contains: String
  plannedDate_not_ends_with: String
  plannedDate_not_in: [String!]
  plannedDate_not_starts_with: String
  plannedDate_starts_with: String
  plannedTime: String
  plannedTime_contains: String
  plannedTime_ends_with: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_not: String
  plannedTime_not_contains: String
  plannedTime_not_ends_with: String
  plannedTime_not_in: [String!]
  plannedTime_not_starts_with: String
  plannedTime_starts_with: String
  priority: String
  priority_contains: String
  priority_ends_with: String
  priority_gt: String
  priority_gte: String
  priority_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_not: String
  priority_not_contains: String
  priority_not_ends_with: String
  priority_not_in: [String!]
  priority_not_starts_with: String
  priority_starts_with: String
  repeat: Int
  repeat_gt: Int
  repeat_gte: Int
  repeat_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_not: Int
  repeat_not_in: [Int!]
}

input TaskUpdateInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
}

input TaskUpdateManyDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
}

input TaskUpdateManyMutationInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
}

input TaskUpdateManyWithoutSubprojectInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutSubprojectInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutSubprojectInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutSubprojectInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneRequiredWithoutTimelogsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTimelogsInput
  update: TaskUpdateWithoutTimelogsDataInput
  upsert: TaskUpsertWithoutTimelogsInput
}

input TaskUpdateWithoutSubprojectDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  timelogs: TimelogUpdateManyWithoutTaskInput
}

input TaskUpdateWithoutTimelogsDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
}

input TaskUpdateWithWhereUniqueWithoutSubprojectInput {
  data: TaskUpdateWithoutSubprojectDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutTimelogsInput {
  create: TaskCreateWithoutTimelogsInput!
  update: TaskUpdateWithoutTimelogsDataInput!
}

input TaskUpsertWithWhereUniqueWithoutSubprojectInput {
  create: TaskCreateWithoutSubprojectInput!
  update: TaskUpdateWithoutSubprojectDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  comments: String
  comments_contains: String
  comments_ends_with: String
  comments_gt: String
  comments_gte: String
  comments_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_not: String
  comments_not_contains: String
  comments_not_ends_with: String
  comments_not_in: [String!]
  comments_not_starts_with: String
  comments_starts_with: String
  completed: Boolean
  completed_not: Boolean
  deadlineDate: String
  deadlineDate_contains: String
  deadlineDate_ends_with: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_not: String
  deadlineDate_not_contains: String
  deadlineDate_not_ends_with: String
  deadlineDate_not_in: [String!]
  deadlineDate_not_starts_with: String
  deadlineDate_starts_with: String
  estimateTime: String
  estimateTime_contains: String
  estimateTime_ends_with: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_not: String
  estimateTime_not_contains: String
  estimateTime_not_ends_with: String
  estimateTime_not_in: [String!]
  estimateTime_not_starts_with: String
  estimateTime_starts_with: String
  finishDate: String
  finishDate_contains: String
  finishDate_ends_with: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_not: String
  finishDate_not_contains: String
  finishDate_not_ends_with: String
  finishDate_not_in: [String!]
  finishDate_not_starts_with: String
  finishDate_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  plannedDate: String
  plannedDate_contains: String
  plannedDate_ends_with: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_not: String
  plannedDate_not_contains: String
  plannedDate_not_ends_with: String
  plannedDate_not_in: [String!]
  plannedDate_not_starts_with: String
  plannedDate_starts_with: String
  plannedTime: String
  plannedTime_contains: String
  plannedTime_ends_with: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_not: String
  plannedTime_not_contains: String
  plannedTime_not_ends_with: String
  plannedTime_not_in: [String!]
  plannedTime_not_starts_with: String
  plannedTime_starts_with: String
  priority: String
  priority_contains: String
  priority_ends_with: String
  priority_gt: String
  priority_gte: String
  priority_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_not: String
  priority_not_contains: String
  priority_not_ends_with: String
  priority_not_in: [String!]
  priority_not_starts_with: String
  priority_starts_with: String
  repeat: Int
  repeat_gt: Int
  repeat_gte: Int
  repeat_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_not: Int
  repeat_not_in: [Int!]
  subproject: SubprojectWhereInput
  timelogs_every: TimelogWhereInput
  timelogs_none: TimelogWhereInput
  timelogs_some: TimelogWhereInput
}

input TaskWhereUniqueInput {
  id: Int
}

type Timelog {
  finishDate: DateTime
  id: Int!
  startDate: DateTime
  task: Task!
}

type TimelogConnection {
  aggregate: AggregateTimelog!
  edges: [TimelogEdge!]!
  pageInfo: PageInfo!
}

input TimelogCreateInput {
  finishDate: DateTime
  id: Int
  startDate: DateTime
  task: TaskCreateOneWithoutTimelogsInput!
}

input TimelogCreateManyWithoutTaskInput {
  connect: [TimelogWhereUniqueInput!]
  create: [TimelogCreateWithoutTaskInput!]
}

input TimelogCreateWithoutTaskInput {
  finishDate: DateTime
  id: Int
  startDate: DateTime
}

type TimelogEdge {
  cursor: String!
  node: Timelog!
}

enum TimelogOrderByInput {
  createdAt_ASC
  createdAt_DESC
  finishDate_ASC
  finishDate_DESC
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TimelogScalarWhereInput {
  AND: [TimelogScalarWhereInput!]
  finishDate: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  finishDate_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_not: DateTime
  finishDate_not_in: [DateTime!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [TimelogScalarWhereInput!]
  OR: [TimelogScalarWhereInput!]
  startDate: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startDate_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_not: DateTime
  startDate_not_in: [DateTime!]
}

input TimelogUpdateInput {
  finishDate: DateTime
  startDate: DateTime
  task: TaskUpdateOneRequiredWithoutTimelogsInput
}

input TimelogUpdateManyDataInput {
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateManyMutationInput {
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateManyWithoutTaskInput {
  connect: [TimelogWhereUniqueInput!]
  create: [TimelogCreateWithoutTaskInput!]
  delete: [TimelogWhereUniqueInput!]
  deleteMany: [TimelogScalarWhereInput!]
  disconnect: [TimelogWhereUniqueInput!]
  set: [TimelogWhereUniqueInput!]
  update: [TimelogUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TimelogUpdateManyWithWhereNestedInput!]
  upsert: [TimelogUpsertWithWhereUniqueWithoutTaskInput!]
}

input TimelogUpdateManyWithWhereNestedInput {
  data: TimelogUpdateManyDataInput!
  where: TimelogScalarWhereInput!
}

input TimelogUpdateWithoutTaskDataInput {
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateWithWhereUniqueWithoutTaskInput {
  data: TimelogUpdateWithoutTaskDataInput!
  where: TimelogWhereUniqueInput!
}

input TimelogUpsertWithWhereUniqueWithoutTaskInput {
  create: TimelogCreateWithoutTaskInput!
  update: TimelogUpdateWithoutTaskDataInput!
  where: TimelogWhereUniqueInput!
}

input TimelogWhereInput {
  AND: [TimelogWhereInput!]
  finishDate: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  finishDate_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_not: DateTime
  finishDate_not_in: [DateTime!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [TimelogWhereInput!]
  OR: [TimelogWhereInput!]
  startDate: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startDate_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_not: DateTime
  startDate_not_in: [DateTime!]
  task: TaskWhereInput
}

input TimelogWhereUniqueInput {
  id: Int
}
