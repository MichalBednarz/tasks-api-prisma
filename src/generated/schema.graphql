### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type AggregateProject {
  count: Int!
}

type AggregateSubproject {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateTimelog {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AuthPayload {
  token: String!
  user: User!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  cloneTask(where: TaskWhereUniqueInput): Task!
  completeTask(where: TaskWhereUniqueInput!): Task!
  createProject(data: ProjectCreateInput!): Project!
  createSubproject(data: SubprojectCreateInput!): Subproject!
  createTag(data: TagCreateInput!): Tag!
  createTask(data: TaskCreateInput!): Task!
  createTimelog(data: TimelogCreateInput!): Timelog!
  createUser(data: UserCreateInput!): User!
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  deleteManySubprojects(where: SubprojectWhereInput): BatchPayload!
  deleteManyTags(where: TagWhereInput): BatchPayload!
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  deleteManyTimelogs(where: TimelogWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteSubproject(where: SubprojectWhereUniqueInput!): Subproject
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteTimelog(where: TimelogWhereUniqueInput!): Timelog
  deleteUser(where: UserWhereUniqueInput!): User
  login(email: String, password: String): AuthPayload!
  startTimelog(data: TimelogCreateInput): Timelog!
  stopTimelog(where: TimelogWhereUniqueInput!): Timelog!
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  updateManySubprojects(data: SubprojectUpdateManyMutationInput!, where: SubprojectWhereInput): BatchPayload!
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  updateManyTasks(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): BatchPayload!
  updateManyTimelogs(data: TimelogUpdateManyMutationInput!, where: TimelogWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateSubproject(data: SubprojectUpdateInput!, where: SubprojectWhereUniqueInput!): Subproject
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateTimelog(data: TimelogUpdateInput!, where: TimelogWhereUniqueInput!): Timelog
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertSubproject(create: SubprojectCreateInput!, update: SubprojectUpdateInput!, where: SubprojectWhereUniqueInput!): Subproject!
  upsertTag(create: TagCreateInput!, update: TagUpdateInput!, where: TagWhereUniqueInput!): Tag!
  upsertTask(create: TaskCreateInput!, update: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task!
  upsertTimelog(create: TimelogCreateInput!, update: TimelogUpdateInput!, where: TimelogWhereUniqueInput!): Timelog!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

enum MutationType {
  CREATED
  DELETED
  UPDATED
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Project {
  estimateTime: String
  id: Int!
  name: String!
  statusTime: String
  subprojects(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): [Subproject!]
  user: User
}

type ProjectConnection {
  aggregate: AggregateProject!
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}

input ProjectCreateInput {
  id: Int
  name: String!
  subprojects: SubprojectCreateManyWithoutProjectInput
  user: UserCreateOneWithoutProjectsInput
}

input ProjectCreateManyWithoutUserInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUserInput!]
}

input ProjectCreateOneWithoutSubprojectsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutSubprojectsInput
}

input ProjectCreateWithoutSubprojectsInput {
  id: Int
  name: String!
  user: UserCreateOneWithoutProjectsInput
}

input ProjectCreateWithoutUserInput {
  id: Int
  name: String!
  subprojects: SubprojectCreateManyWithoutProjectInput
}

type ProjectEdge {
  cursor: String!
  node: Project!
}

enum ProjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
}

input ProjectUpdateInput {
  name: String
  subprojects: SubprojectUpdateManyWithoutProjectInput
  user: UserUpdateOneWithoutProjectsInput
}

input ProjectUpdateManyDataInput {
  name: String
}

input ProjectUpdateManyMutationInput {
  name: String
}

input ProjectUpdateManyWithoutUserInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUserInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUserInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  data: ProjectUpdateManyDataInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateOneRequiredWithoutSubprojectsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutSubprojectsInput
  update: ProjectUpdateWithoutSubprojectsDataInput
  upsert: ProjectUpsertWithoutSubprojectsInput
}

input ProjectUpdateWithoutSubprojectsDataInput {
  name: String
  user: UserUpdateOneWithoutProjectsInput
}

input ProjectUpdateWithoutUserDataInput {
  name: String
  subprojects: SubprojectUpdateManyWithoutProjectInput
}

input ProjectUpdateWithWhereUniqueWithoutUserInput {
  data: ProjectUpdateWithoutUserDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutSubprojectsInput {
  create: ProjectCreateWithoutSubprojectsInput!
  update: ProjectUpdateWithoutSubprojectsDataInput!
}

input ProjectUpsertWithWhereUniqueWithoutUserInput {
  create: ProjectCreateWithoutUserInput!
  update: ProjectUpdateWithoutUserDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  subprojects_every: SubprojectWhereInput
  subprojects_none: SubprojectWhereInput
  subprojects_some: SubprojectWhereInput
  user: UserWhereInput
}

input ProjectWhereUniqueInput {
  id: Int
  name: String
}

type Query {
  activeTimelog: Timelog
  project(where: ProjectWhereUniqueInput!): Project
  projects(after: String, before: String, first: Int, last: Int, orderBy: ProjectOrderByInput, skip: Int, where: ProjectWhereInput): [Project!]!
  projectsConnection(after: String, before: String, first: Int, last: Int, orderBy: ProjectOrderByInput, skip: Int, where: ProjectWhereInput): ProjectConnection!
  subproject(where: SubprojectWhereUniqueInput!): Subproject
  subprojects(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): [Subproject!]!
  subprojectsConnection(after: String, before: String, first: Int, last: Int, orderBy: SubprojectOrderByInput, skip: Int, where: SubprojectWhereInput): SubprojectConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(after: String, before: String, first: Int, last: Int, orderBy: TagOrderByInput, skip: Int, where: TagWhereInput): [Tag!]!
  tagsConnection(after: String, before: String, first: Int, last: Int, orderBy: TagOrderByInput, skip: Int, where: TagWhereInput): TagConnection!
  task(where: TaskWhereUniqueInput!): Task
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]!
  tasksConnection(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): TaskConnection!
  timelog(where: TimelogWhereUniqueInput!): Timelog
  timelogs(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): [Timelog!]!
  timelogsConnection(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): TimelogConnection!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type Subproject {
  estimateTime: String
  id: Int!
  name: String!
  project: Project!
  statusTime: String
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]
}

type SubprojectConnection {
  aggregate: AggregateSubproject!
  edges: [SubprojectEdge!]!
  pageInfo: PageInfo!
}

input SubprojectCreateInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateManyWithoutProjectInput {
  connect: [SubprojectWhereUniqueInput!]
  create: [SubprojectCreateWithoutProjectInput!]
}

input SubprojectCreateOneWithoutTasksInput {
  connect: SubprojectWhereUniqueInput
  create: SubprojectCreateWithoutTasksInput
}

input SubprojectCreateWithoutProjectInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateWithoutTasksInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
}

type SubprojectEdge {
  cursor: String!
  node: Subproject!
}

enum SubprojectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SubprojectScalarWhereInput {
  AND: [SubprojectScalarWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [SubprojectScalarWhereInput!]
  OR: [SubprojectScalarWhereInput!]
}

input SubprojectUpdateInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateManyDataInput {
  name: String
}

input SubprojectUpdateManyMutationInput {
  name: String
}

input SubprojectUpdateManyWithoutProjectInput {
  connect: [SubprojectWhereUniqueInput!]
  create: [SubprojectCreateWithoutProjectInput!]
  delete: [SubprojectWhereUniqueInput!]
  deleteMany: [SubprojectScalarWhereInput!]
  disconnect: [SubprojectWhereUniqueInput!]
  set: [SubprojectWhereUniqueInput!]
  update: [SubprojectUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [SubprojectUpdateManyWithWhereNestedInput!]
  upsert: [SubprojectUpsertWithWhereUniqueWithoutProjectInput!]
}

input SubprojectUpdateManyWithWhereNestedInput {
  data: SubprojectUpdateManyDataInput!
  where: SubprojectScalarWhereInput!
}

input SubprojectUpdateOneWithoutTasksInput {
  connect: SubprojectWhereUniqueInput
  create: SubprojectCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: SubprojectUpdateWithoutTasksDataInput
  upsert: SubprojectUpsertWithoutTasksInput
}

input SubprojectUpdateWithoutProjectDataInput {
  name: String
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateWithoutTasksDataInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
}

input SubprojectUpdateWithWhereUniqueWithoutProjectInput {
  data: SubprojectUpdateWithoutProjectDataInput!
  where: SubprojectWhereUniqueInput!
}

input SubprojectUpsertWithoutTasksInput {
  create: SubprojectCreateWithoutTasksInput!
  update: SubprojectUpdateWithoutTasksDataInput!
}

input SubprojectUpsertWithWhereUniqueWithoutProjectInput {
  create: SubprojectCreateWithoutProjectInput!
  update: SubprojectUpdateWithoutProjectDataInput!
  where: SubprojectWhereUniqueInput!
}

input SubprojectWhereInput {
  AND: [SubprojectWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [SubprojectWhereInput!]
  OR: [SubprojectWhereInput!]
  project: ProjectWhereInput
  tasks_every: TaskWhereInput
  tasks_none: TaskWhereInput
  tasks_some: TaskWhereInput
}

input SubprojectWhereUniqueInput {
  id: Int
  name: String
}

type Subscription {
  task(where: TaskSubscriptionWhereInput!): TaskSubscriptionPayload!
}

type Tag {
  id: Int!
  name: String!
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]
  user: User
}

type TagConnection {
  aggregate: AggregateTag!
  edges: [TagEdge!]!
  pageInfo: PageInfo!
}

input TagCreateInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutTagsInput
  user: UserCreateOneWithoutTagsInput
}

input TagCreateManyWithoutTasksInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutTasksInput!]
}

input TagCreateManyWithoutUserInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutUserInput!]
}

input TagCreateWithoutTasksInput {
  id: Int
  name: String!
  user: UserCreateOneWithoutTagsInput
}

input TagCreateWithoutUserInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutTagsInput
}

type TagEdge {
  cursor: String!
  node: Tag!
}

enum TagOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
}

input TagUpdateInput {
  name: String
  tasks: TaskUpdateManyWithoutTagsInput
  user: UserUpdateOneWithoutTagsInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithoutTasksInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutTasksInput!]
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutTasksInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutTasksInput!]
}

input TagUpdateManyWithoutUserInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutUserInput!]
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutUserInput!]
}

input TagUpdateManyWithWhereNestedInput {
  data: TagUpdateManyDataInput!
  where: TagScalarWhereInput!
}

input TagUpdateWithoutTasksDataInput {
  name: String
  user: UserUpdateOneWithoutTagsInput
}

input TagUpdateWithoutUserDataInput {
  name: String
  tasks: TaskUpdateManyWithoutTagsInput
}

input TagUpdateWithWhereUniqueWithoutTasksInput {
  data: TagUpdateWithoutTasksDataInput!
  where: TagWhereUniqueInput!
}

input TagUpdateWithWhereUniqueWithoutUserInput {
  data: TagUpdateWithoutUserDataInput!
  where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutTasksInput {
  create: TagCreateWithoutTasksInput!
  update: TagUpdateWithoutTasksDataInput!
  where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutUserInput {
  create: TagCreateWithoutUserInput!
  update: TagUpdateWithoutUserDataInput!
  where: TagWhereUniqueInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  tasks_every: TaskWhereInput
  tasks_none: TaskWhereInput
  tasks_some: TaskWhereInput
  user: UserWhereInput
}

input TagWhereUniqueInput {
  id: Int
  name: String
}

type Task {
  comments: String
  completed: Boolean!
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int!
  latestTimelogStartDate: String
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  project: Project
  repeat: Int
  statusTime: String
  subproject: Subproject
  tags(after: String, before: String, first: Int, last: Int, orderBy: TagOrderByInput, skip: Int, where: TagWhereInput): [Tag!]
  timelogCount: String!
  timelogs(after: String, before: String, first: Int, last: Int, orderBy: TimelogOrderByInput, skip: Int, where: TimelogWhereInput): [Timelog!]
  user: User
}

type TaskConnection {
  aggregate: AggregateTask!
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

input TaskCreateInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
  tags: TagCreateManyWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateManyWithoutSubprojectInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutSubprojectInput!]
}

input TaskCreateManyWithoutTagsInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutTagsInput!]
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateOneWithoutTimelogsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTimelogsInput
}

input TaskCreateWithoutSubprojectInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  tags: TagCreateManyWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutTagsInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutTimelogsInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
  tags: TagCreateManyWithoutTasksInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutUserInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectCreateOneWithoutTasksInput
  tags: TagCreateManyWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
}

type TaskEdge {
  cursor: String!
  node: Task!
}

enum TaskOrderByInput {
  comments_ASC
  comments_DESC
  completed_ASC
  completed_DESC
  createdAt_ASC
  createdAt_DESC
  deadlineDate_ASC
  deadlineDate_DESC
  estimateTime_ASC
  estimateTime_DESC
  finishDate_ASC
  finishDate_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  plannedDate_ASC
  plannedDate_DESC
  plannedTime_ASC
  plannedTime_DESC
  priority_ASC
  priority_DESC
  repeat_ASC
  repeat_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TaskPreviousValues {
  comments: String
  completed: Boolean!
  deadlineDate: String
  estimateTime: String
  finishDate: String
  id: Int!
  name: String!
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  comments: String
  comments_contains: String
  comments_ends_with: String
  comments_gt: String
  comments_gte: String
  comments_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_not: String
  comments_not_contains: String
  comments_not_ends_with: String
  comments_not_in: [String!]
  comments_not_starts_with: String
  comments_starts_with: String
  completed: Boolean
  completed_not: Boolean
  deadlineDate: String
  deadlineDate_contains: String
  deadlineDate_ends_with: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_not: String
  deadlineDate_not_contains: String
  deadlineDate_not_ends_with: String
  deadlineDate_not_in: [String!]
  deadlineDate_not_starts_with: String
  deadlineDate_starts_with: String
  estimateTime: String
  estimateTime_contains: String
  estimateTime_ends_with: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_not: String
  estimateTime_not_contains: String
  estimateTime_not_ends_with: String
  estimateTime_not_in: [String!]
  estimateTime_not_starts_with: String
  estimateTime_starts_with: String
  finishDate: String
  finishDate_contains: String
  finishDate_ends_with: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_not: String
  finishDate_not_contains: String
  finishDate_not_ends_with: String
  finishDate_not_in: [String!]
  finishDate_not_starts_with: String
  finishDate_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  plannedDate: String
  plannedDate_contains: String
  plannedDate_ends_with: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_not: String
  plannedDate_not_contains: String
  plannedDate_not_ends_with: String
  plannedDate_not_in: [String!]
  plannedDate_not_starts_with: String
  plannedDate_starts_with: String
  plannedTime: String
  plannedTime_contains: String
  plannedTime_ends_with: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_not: String
  plannedTime_not_contains: String
  plannedTime_not_ends_with: String
  plannedTime_not_in: [String!]
  plannedTime_not_starts_with: String
  plannedTime_starts_with: String
  priority: String
  priority_contains: String
  priority_ends_with: String
  priority_gt: String
  priority_gte: String
  priority_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_not: String
  priority_not_contains: String
  priority_not_ends_with: String
  priority_not_in: [String!]
  priority_not_starts_with: String
  priority_starts_with: String
  repeat: Int
  repeat_gt: Int
  repeat_gte: Int
  repeat_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_not: Int
  repeat_not_in: [Int!]
}

type TaskSubscriptionPayload {
  mutation: MutationType!
  node: Task
  previousValues: TaskPreviousValues
  updatedFields: [String!]
}

input TaskSubscriptionWhereInput {
  AND: [TaskSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  node: TaskWhereInput
  NOT: [TaskSubscriptionWhereInput!]
  OR: [TaskSubscriptionWhereInput!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
}

input TaskUpdateInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
  tags: TagUpdateManyWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateManyDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
}

input TaskUpdateManyMutationInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
}

input TaskUpdateManyWithoutSubprojectInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutSubprojectInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutSubprojectInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutSubprojectInput!]
}

input TaskUpdateManyWithoutTagsInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutTagsInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutTagsInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutTagsInput!]
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneRequiredWithoutTimelogsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTimelogsInput
  update: TaskUpdateWithoutTimelogsDataInput
  upsert: TaskUpsertWithoutTimelogsInput
}

input TaskUpdateWithoutSubprojectDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  tags: TagUpdateManyWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutTagsDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutTimelogsDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
  tags: TagUpdateManyWithoutTasksInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutUserDataInput {
  comments: String
  completed: Boolean
  deadlineDate: String
  estimateTime: String
  finishDate: String
  name: String
  plannedDate: String
  plannedTime: String
  priority: String
  repeat: Int
  subproject: SubprojectUpdateOneWithoutTasksInput
  tags: TagUpdateManyWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
}

input TaskUpdateWithWhereUniqueWithoutSubprojectInput {
  data: TaskUpdateWithoutSubprojectDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpdateWithWhereUniqueWithoutTagsInput {
  data: TaskUpdateWithoutTagsDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutTimelogsInput {
  create: TaskCreateWithoutTimelogsInput!
  update: TaskUpdateWithoutTimelogsDataInput!
}

input TaskUpsertWithWhereUniqueWithoutSubprojectInput {
  create: TaskCreateWithoutSubprojectInput!
  update: TaskUpdateWithoutSubprojectDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithWhereUniqueWithoutTagsInput {
  create: TaskCreateWithoutTagsInput!
  update: TaskUpdateWithoutTagsDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  comments: String
  comments_contains: String
  comments_ends_with: String
  comments_gt: String
  comments_gte: String
  comments_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_not: String
  comments_not_contains: String
  comments_not_ends_with: String
  comments_not_in: [String!]
  comments_not_starts_with: String
  comments_starts_with: String
  completed: Boolean
  completed_not: Boolean
  deadlineDate: String
  deadlineDate_contains: String
  deadlineDate_ends_with: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_not: String
  deadlineDate_not_contains: String
  deadlineDate_not_ends_with: String
  deadlineDate_not_in: [String!]
  deadlineDate_not_starts_with: String
  deadlineDate_starts_with: String
  estimateTime: String
  estimateTime_contains: String
  estimateTime_ends_with: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_not: String
  estimateTime_not_contains: String
  estimateTime_not_ends_with: String
  estimateTime_not_in: [String!]
  estimateTime_not_starts_with: String
  estimateTime_starts_with: String
  finishDate: String
  finishDate_contains: String
  finishDate_ends_with: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_not: String
  finishDate_not_contains: String
  finishDate_not_ends_with: String
  finishDate_not_in: [String!]
  finishDate_not_starts_with: String
  finishDate_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  plannedDate: String
  plannedDate_contains: String
  plannedDate_ends_with: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_not: String
  plannedDate_not_contains: String
  plannedDate_not_ends_with: String
  plannedDate_not_in: [String!]
  plannedDate_not_starts_with: String
  plannedDate_starts_with: String
  plannedTime: String
  plannedTime_contains: String
  plannedTime_ends_with: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_not: String
  plannedTime_not_contains: String
  plannedTime_not_ends_with: String
  plannedTime_not_in: [String!]
  plannedTime_not_starts_with: String
  plannedTime_starts_with: String
  priority: String
  priority_contains: String
  priority_ends_with: String
  priority_gt: String
  priority_gte: String
  priority_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_not: String
  priority_not_contains: String
  priority_not_ends_with: String
  priority_not_in: [String!]
  priority_not_starts_with: String
  priority_starts_with: String
  repeat: Int
  repeat_gt: Int
  repeat_gte: Int
  repeat_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_not: Int
  repeat_not_in: [Int!]
  subproject: SubprojectWhereInput
  tags_every: TagWhereInput
  tags_none: TagWhereInput
  tags_some: TagWhereInput
  timelogs_every: TimelogWhereInput
  timelogs_none: TimelogWhereInput
  timelogs_some: TimelogWhereInput
  user: UserWhereInput
}

input TaskWhereUniqueInput {
  id: Int
}

type Timelog {
  description: String
  finishDate: DateTime
  id: Int!
  startDate: DateTime
  task: Task!
}

type TimelogConnection {
  aggregate: AggregateTimelog!
  edges: [TimelogEdge!]!
  pageInfo: PageInfo!
}

input TimelogCreateInput {
  description: String
  finishDate: DateTime
  id: Int
  startDate: DateTime
  task: TaskCreateOneWithoutTimelogsInput!
}

input TimelogCreateManyWithoutTaskInput {
  connect: [TimelogWhereUniqueInput!]
  create: [TimelogCreateWithoutTaskInput!]
}

input TimelogCreateWithoutTaskInput {
  description: String
  finishDate: DateTime
  id: Int
  startDate: DateTime
}

type TimelogEdge {
  cursor: String!
  node: Timelog!
}

enum TimelogOrderByInput {
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  finishDate_ASC
  finishDate_DESC
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TimelogScalarWhereInput {
  AND: [TimelogScalarWhereInput!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  finishDate: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  finishDate_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_not: DateTime
  finishDate_not_in: [DateTime!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [TimelogScalarWhereInput!]
  OR: [TimelogScalarWhereInput!]
  startDate: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startDate_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_not: DateTime
  startDate_not_in: [DateTime!]
}

input TimelogUpdateInput {
  description: String
  finishDate: DateTime
  startDate: DateTime
  task: TaskUpdateOneRequiredWithoutTimelogsInput
}

input TimelogUpdateManyDataInput {
  description: String
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateManyMutationInput {
  description: String
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateManyWithoutTaskInput {
  connect: [TimelogWhereUniqueInput!]
  create: [TimelogCreateWithoutTaskInput!]
  delete: [TimelogWhereUniqueInput!]
  deleteMany: [TimelogScalarWhereInput!]
  disconnect: [TimelogWhereUniqueInput!]
  set: [TimelogWhereUniqueInput!]
  update: [TimelogUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TimelogUpdateManyWithWhereNestedInput!]
  upsert: [TimelogUpsertWithWhereUniqueWithoutTaskInput!]
}

input TimelogUpdateManyWithWhereNestedInput {
  data: TimelogUpdateManyDataInput!
  where: TimelogScalarWhereInput!
}

input TimelogUpdateWithoutTaskDataInput {
  description: String
  finishDate: DateTime
  startDate: DateTime
}

input TimelogUpdateWithWhereUniqueWithoutTaskInput {
  data: TimelogUpdateWithoutTaskDataInput!
  where: TimelogWhereUniqueInput!
}

input TimelogUpsertWithWhereUniqueWithoutTaskInput {
  create: TimelogCreateWithoutTaskInput!
  update: TimelogUpdateWithoutTaskDataInput!
  where: TimelogWhereUniqueInput!
}

input TimelogWhereInput {
  AND: [TimelogWhereInput!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  finishDate: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  finishDate_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_not: DateTime
  finishDate_not_in: [DateTime!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [TimelogWhereInput!]
  OR: [TimelogWhereInput!]
  startDate: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startDate_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_not: DateTime
  startDate_not_in: [DateTime!]
  task: TaskWhereInput
}

input TimelogWhereUniqueInput {
  id: Int
}

type User {
  email: String!
  id: Int!
  password: String!
  projects(after: String, before: String, first: Int, last: Int, orderBy: ProjectOrderByInput, skip: Int, where: ProjectWhereInput): [Project!]
  tags(after: String, before: String, first: Int, last: Int, orderBy: TagOrderByInput, skip: Int, where: TagWhereInput): [Tag!]
  tasks(after: String, before: String, first: Int, last: Int, orderBy: TaskOrderByInput, skip: Int, where: TaskWhereInput): [Task!]
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  email: String!
  id: Int
  password: String!
  projects: ProjectCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
  tasks: TaskCreateManyWithoutUserInput
}

input UserCreateOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectsInput
}

input UserCreateOneWithoutTagsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTagsInput
}

input UserCreateOneWithoutTasksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTasksInput
}

input UserCreateWithoutProjectsInput {
  email: String!
  id: Int
  password: String!
  tags: TagCreateManyWithoutUserInput
  tasks: TaskCreateManyWithoutUserInput
}

input UserCreateWithoutTagsInput {
  email: String!
  id: Int
  password: String!
  projects: ProjectCreateManyWithoutUserInput
  tasks: TaskCreateManyWithoutUserInput
}

input UserCreateWithoutTasksInput {
  email: String!
  id: Int
  password: String!
  projects: ProjectCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  password_ASC
  password_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserUpdateInput {
  email: String
  password: String
  projects: ProjectUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
  tasks: TaskUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
}

input UserUpdateOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutProjectsDataInput
  upsert: UserUpsertWithoutProjectsInput
}

input UserUpdateOneWithoutTagsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTagsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTagsDataInput
  upsert: UserUpsertWithoutTagsInput
}

input UserUpdateOneWithoutTasksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTasksDataInput
  upsert: UserUpsertWithoutTasksInput
}

input UserUpdateWithoutProjectsDataInput {
  email: String
  password: String
  tags: TagUpdateManyWithoutUserInput
  tasks: TaskUpdateManyWithoutUserInput
}

input UserUpdateWithoutTagsDataInput {
  email: String
  password: String
  projects: ProjectUpdateManyWithoutUserInput
  tasks: TaskUpdateManyWithoutUserInput
}

input UserUpdateWithoutTasksDataInput {
  email: String
  password: String
  projects: ProjectUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
}

input UserUpsertWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsDataInput!
}

input UserUpsertWithoutTagsInput {
  create: UserCreateWithoutTagsInput!
  update: UserUpdateWithoutTagsDataInput!
}

input UserUpsertWithoutTasksInput {
  create: UserCreateWithoutTasksInput!
  update: UserUpdateWithoutTasksDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  projects_every: ProjectWhereInput
  projects_none: ProjectWhereInput
  projects_some: ProjectWhereInput
  tags_every: TagWhereInput
  tags_none: TagWhereInput
  tags_some: TagWhereInput
  tasks_every: TaskWhereInput
  tasks_none: TaskWhereInput
  tasks_some: TaskWhereInput
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
