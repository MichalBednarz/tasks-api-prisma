// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateProject {
  count: Int!
}

type AggregateSubproject {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTask {
  count: Int!
}

type AggregateTimelog {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createSubproject(data: SubprojectCreateInput!): Subproject!
  updateSubproject(data: SubprojectUpdateInput!, where: SubprojectWhereUniqueInput!): Subproject
  updateManySubprojects(data: SubprojectUpdateManyMutationInput!, where: SubprojectWhereInput): BatchPayload!
  upsertSubproject(where: SubprojectWhereUniqueInput!, create: SubprojectCreateInput!, update: SubprojectUpdateInput!): Subproject!
  deleteSubproject(where: SubprojectWhereUniqueInput!): Subproject
  deleteManySubprojects(where: SubprojectWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createTask(data: TaskCreateInput!): Task!
  updateTask(data: TaskUpdateInput!, where: TaskWhereUniqueInput!): Task
  updateManyTasks(data: TaskUpdateManyMutationInput!, where: TaskWhereInput): BatchPayload!
  upsertTask(where: TaskWhereUniqueInput!, create: TaskCreateInput!, update: TaskUpdateInput!): Task!
  deleteTask(where: TaskWhereUniqueInput!): Task
  deleteManyTasks(where: TaskWhereInput): BatchPayload!
  createTimelog(data: TimelogCreateInput!): Timelog!
  updateTimelog(data: TimelogUpdateInput!, where: TimelogWhereUniqueInput!): Timelog
  updateManyTimelogs(data: TimelogUpdateManyMutationInput!, where: TimelogWhereInput): BatchPayload!
  upsertTimelog(where: TimelogWhereUniqueInput!, create: TimelogCreateInput!, update: TimelogUpdateInput!): Timelog!
  deleteTimelog(where: TimelogWhereUniqueInput!): Timelog
  deleteManyTimelogs(where: TimelogWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Project {
  id: Int!
  name: String!
  subprojects(where: SubprojectWhereInput, orderBy: SubprojectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subproject!]
  user: User
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: Int
  name: String!
  subprojects: SubprojectCreateManyWithoutProjectInput
  user: UserCreateOneWithoutProjectsInput
}

input ProjectCreateManyWithoutUserInput {
  create: [ProjectCreateWithoutUserInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutSubprojectsInput {
  create: ProjectCreateWithoutSubprojectsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutSubprojectsInput {
  id: Int
  name: String!
  user: UserCreateOneWithoutProjectsInput
}

input ProjectCreateWithoutUserInput {
  id: Int
  name: String!
  subprojects: SubprojectCreateManyWithoutProjectInput
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ProjectPreviousValues {
  id: Int!
  name: String!
}

input ProjectScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  name: String
  subprojects: SubprojectUpdateManyWithoutProjectInput
  user: UserUpdateOneWithoutProjectsInput
}

input ProjectUpdateManyDataInput {
  name: String
}

input ProjectUpdateManyMutationInput {
  name: String
}

input ProjectUpdateManyWithoutUserInput {
  create: [ProjectCreateWithoutUserInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneRequiredWithoutSubprojectsInput {
  create: ProjectCreateWithoutSubprojectsInput
  update: ProjectUpdateWithoutSubprojectsDataInput
  upsert: ProjectUpsertWithoutSubprojectsInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutSubprojectsDataInput {
  name: String
  user: UserUpdateOneWithoutProjectsInput
}

input ProjectUpdateWithoutUserDataInput {
  name: String
  subprojects: SubprojectUpdateManyWithoutProjectInput
}

input ProjectUpdateWithWhereUniqueWithoutUserInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutUserDataInput!
}

input ProjectUpsertWithoutSubprojectsInput {
  update: ProjectUpdateWithoutSubprojectsDataInput!
  create: ProjectCreateWithoutSubprojectsInput!
}

input ProjectUpsertWithWhereUniqueWithoutUserInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutUserDataInput!
  create: ProjectCreateWithoutUserInput!
}

input ProjectWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  subprojects_every: SubprojectWhereInput
  subprojects_some: SubprojectWhereInput
  subprojects_none: SubprojectWhereInput
  user: UserWhereInput
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: Int
  name: String
}

type Query {
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  subproject(where: SubprojectWhereUniqueInput!): Subproject
  subprojects(where: SubprojectWhereInput, orderBy: SubprojectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subproject]!
  subprojectsConnection(where: SubprojectWhereInput, orderBy: SubprojectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubprojectConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  task(where: TaskWhereUniqueInput!): Task
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task]!
  tasksConnection(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaskConnection!
  timelog(where: TimelogWhereUniqueInput!): Timelog
  timelogs(where: TimelogWhereInput, orderBy: TimelogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Timelog]!
  timelogsConnection(where: TimelogWhereInput, orderBy: TimelogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimelogConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subproject {
  id: Int!
  name: String!
  project: Project!
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task!]
}

type SubprojectConnection {
  pageInfo: PageInfo!
  edges: [SubprojectEdge]!
  aggregate: AggregateSubproject!
}

input SubprojectCreateInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateManyWithoutProjectInput {
  create: [SubprojectCreateWithoutProjectInput!]
  connect: [SubprojectWhereUniqueInput!]
}

input SubprojectCreateOneWithoutTasksInput {
  create: SubprojectCreateWithoutTasksInput
  connect: SubprojectWhereUniqueInput
}

input SubprojectCreateWithoutProjectInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutSubprojectInput
}

input SubprojectCreateWithoutTasksInput {
  id: Int
  name: String!
  project: ProjectCreateOneWithoutSubprojectsInput!
}

type SubprojectEdge {
  node: Subproject!
  cursor: String!
}

enum SubprojectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SubprojectPreviousValues {
  id: Int!
  name: String!
}

input SubprojectScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SubprojectScalarWhereInput!]
  OR: [SubprojectScalarWhereInput!]
  NOT: [SubprojectScalarWhereInput!]
}

type SubprojectSubscriptionPayload {
  mutation: MutationType!
  node: Subproject
  updatedFields: [String!]
  previousValues: SubprojectPreviousValues
}

input SubprojectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubprojectWhereInput
  AND: [SubprojectSubscriptionWhereInput!]
  OR: [SubprojectSubscriptionWhereInput!]
  NOT: [SubprojectSubscriptionWhereInput!]
}

input SubprojectUpdateInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateManyDataInput {
  name: String
}

input SubprojectUpdateManyMutationInput {
  name: String
}

input SubprojectUpdateManyWithoutProjectInput {
  create: [SubprojectCreateWithoutProjectInput!]
  delete: [SubprojectWhereUniqueInput!]
  connect: [SubprojectWhereUniqueInput!]
  set: [SubprojectWhereUniqueInput!]
  disconnect: [SubprojectWhereUniqueInput!]
  update: [SubprojectUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [SubprojectUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [SubprojectScalarWhereInput!]
  updateMany: [SubprojectUpdateManyWithWhereNestedInput!]
}

input SubprojectUpdateManyWithWhereNestedInput {
  where: SubprojectScalarWhereInput!
  data: SubprojectUpdateManyDataInput!
}

input SubprojectUpdateOneWithoutTasksInput {
  create: SubprojectCreateWithoutTasksInput
  update: SubprojectUpdateWithoutTasksDataInput
  upsert: SubprojectUpsertWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  connect: SubprojectWhereUniqueInput
}

input SubprojectUpdateWithoutProjectDataInput {
  name: String
  tasks: TaskUpdateManyWithoutSubprojectInput
}

input SubprojectUpdateWithoutTasksDataInput {
  name: String
  project: ProjectUpdateOneRequiredWithoutSubprojectsInput
}

input SubprojectUpdateWithWhereUniqueWithoutProjectInput {
  where: SubprojectWhereUniqueInput!
  data: SubprojectUpdateWithoutProjectDataInput!
}

input SubprojectUpsertWithoutTasksInput {
  update: SubprojectUpdateWithoutTasksDataInput!
  create: SubprojectCreateWithoutTasksInput!
}

input SubprojectUpsertWithWhereUniqueWithoutProjectInput {
  where: SubprojectWhereUniqueInput!
  update: SubprojectUpdateWithoutProjectDataInput!
  create: SubprojectCreateWithoutProjectInput!
}

input SubprojectWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  project: ProjectWhereInput
  tasks_every: TaskWhereInput
  tasks_some: TaskWhereInput
  tasks_none: TaskWhereInput
  AND: [SubprojectWhereInput!]
  OR: [SubprojectWhereInput!]
  NOT: [SubprojectWhereInput!]
}

input SubprojectWhereUniqueInput {
  id: Int
  name: String
}

type Subscription {
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  subproject(where: SubprojectSubscriptionWhereInput): SubprojectSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  task(where: TaskSubscriptionWhereInput): TaskSubscriptionPayload
  timelog(where: TimelogSubscriptionWhereInput): TimelogSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: Int!
  name: String!
  user: User
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task!]
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: Int
  name: String!
  user: UserCreateOneWithoutTagsInput
  tasks: TaskCreateManyWithoutTagsInput
}

input TagCreateManyWithoutTasksInput {
  create: [TagCreateWithoutTasksInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
  connect: [TagWhereUniqueInput!]
}

input TagCreateWithoutTasksInput {
  id: Int
  name: String!
  user: UserCreateOneWithoutTagsInput
}

input TagCreateWithoutUserInput {
  id: Int
  name: String!
  tasks: TaskCreateManyWithoutTagsInput
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type TagPreviousValues {
  id: Int!
  name: String!
}

input TagScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateInput {
  name: String
  user: UserUpdateOneWithoutTagsInput
  tasks: TaskUpdateManyWithoutTagsInput
}

input TagUpdateManyDataInput {
  name: String
}

input TagUpdateManyMutationInput {
  name: String
}

input TagUpdateManyWithoutTasksInput {
  create: [TagCreateWithoutTasksInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutTasksInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutTasksInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyWithoutUserInput {
  create: [TagCreateWithoutUserInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithoutTasksDataInput {
  name: String
  user: UserUpdateOneWithoutTagsInput
}

input TagUpdateWithoutUserDataInput {
  name: String
  tasks: TaskUpdateManyWithoutTagsInput
}

input TagUpdateWithWhereUniqueWithoutTasksInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutTasksDataInput!
}

input TagUpdateWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput!
  data: TagUpdateWithoutUserDataInput!
}

input TagUpsertWithWhereUniqueWithoutTasksInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutTasksDataInput!
  create: TagCreateWithoutTasksInput!
}

input TagUpsertWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput!
  update: TagUpdateWithoutUserDataInput!
  create: TagCreateWithoutUserInput!
}

input TagWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  user: UserWhereInput
  tasks_every: TaskWhereInput
  tasks_some: TaskWhereInput
  tasks_none: TaskWhereInput
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: Int
  name: String
}

type Task {
  id: Int!
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean!
  subproject: Subproject
  timelogs(where: TimelogWhereInput, orderBy: TimelogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Timelog!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  user: User
}

type TaskConnection {
  pageInfo: PageInfo!
  edges: [TaskEdge]!
  aggregate: AggregateTask!
}

input TaskCreateInput {
  id: Int
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectCreateOneWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  tags: TagCreateManyWithoutTasksInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateManyWithoutSubprojectInput {
  create: [TaskCreateWithoutSubprojectInput!]
  connect: [TaskWhereUniqueInput!]
}

input TaskCreateManyWithoutTagsInput {
  create: [TaskCreateWithoutTagsInput!]
  connect: [TaskWhereUniqueInput!]
}

input TaskCreateManyWithoutUserInput {
  create: [TaskCreateWithoutUserInput!]
  connect: [TaskWhereUniqueInput!]
}

input TaskCreateOneWithoutTimelogsInput {
  create: TaskCreateWithoutTimelogsInput
  connect: TaskWhereUniqueInput
}

input TaskCreateWithoutSubprojectInput {
  id: Int
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  timelogs: TimelogCreateManyWithoutTaskInput
  tags: TagCreateManyWithoutTasksInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutTagsInput {
  id: Int
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectCreateOneWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutTimelogsInput {
  id: Int
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectCreateOneWithoutTasksInput
  tags: TagCreateManyWithoutTasksInput
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutUserInput {
  id: Int
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectCreateOneWithoutTasksInput
  timelogs: TimelogCreateManyWithoutTaskInput
  tags: TagCreateManyWithoutTasksInput
}

type TaskEdge {
  node: Task!
  cursor: String!
}

enum TaskOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  priority_ASC
  priority_DESC
  comments_ASC
  comments_DESC
  repeat_ASC
  repeat_DESC
  estimateTime_ASC
  estimateTime_DESC
  plannedTime_ASC
  plannedTime_DESC
  plannedDate_ASC
  plannedDate_DESC
  finishDate_ASC
  finishDate_DESC
  deadlineDate_ASC
  deadlineDate_DESC
  completed_ASC
  completed_DESC
}

type TaskPreviousValues {
  id: Int!
  name: String!
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean!
}

input TaskScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  priority: String
  priority_not: String
  priority_in: [String!]
  priority_not_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_gt: String
  priority_gte: String
  priority_contains: String
  priority_not_contains: String
  priority_starts_with: String
  priority_not_starts_with: String
  priority_ends_with: String
  priority_not_ends_with: String
  comments: String
  comments_not: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_gt: String
  comments_gte: String
  comments_contains: String
  comments_not_contains: String
  comments_starts_with: String
  comments_not_starts_with: String
  comments_ends_with: String
  comments_not_ends_with: String
  repeat: Int
  repeat_not: Int
  repeat_in: [Int!]
  repeat_not_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_gt: Int
  repeat_gte: Int
  estimateTime: String
  estimateTime_not: String
  estimateTime_in: [String!]
  estimateTime_not_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_contains: String
  estimateTime_not_contains: String
  estimateTime_starts_with: String
  estimateTime_not_starts_with: String
  estimateTime_ends_with: String
  estimateTime_not_ends_with: String
  plannedTime: String
  plannedTime_not: String
  plannedTime_in: [String!]
  plannedTime_not_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_contains: String
  plannedTime_not_contains: String
  plannedTime_starts_with: String
  plannedTime_not_starts_with: String
  plannedTime_ends_with: String
  plannedTime_not_ends_with: String
  plannedDate: String
  plannedDate_not: String
  plannedDate_in: [String!]
  plannedDate_not_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_contains: String
  plannedDate_not_contains: String
  plannedDate_starts_with: String
  plannedDate_not_starts_with: String
  plannedDate_ends_with: String
  plannedDate_not_ends_with: String
  finishDate: String
  finishDate_not: String
  finishDate_in: [String!]
  finishDate_not_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_contains: String
  finishDate_not_contains: String
  finishDate_starts_with: String
  finishDate_not_starts_with: String
  finishDate_ends_with: String
  finishDate_not_ends_with: String
  deadlineDate: String
  deadlineDate_not: String
  deadlineDate_in: [String!]
  deadlineDate_not_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_contains: String
  deadlineDate_not_contains: String
  deadlineDate_starts_with: String
  deadlineDate_not_starts_with: String
  deadlineDate_ends_with: String
  deadlineDate_not_ends_with: String
  completed: Boolean
  completed_not: Boolean
  AND: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  NOT: [TaskScalarWhereInput!]
}

type TaskSubscriptionPayload {
  mutation: MutationType!
  node: Task
  updatedFields: [String!]
  previousValues: TaskPreviousValues
}

input TaskSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TaskWhereInput
  AND: [TaskSubscriptionWhereInput!]
  OR: [TaskSubscriptionWhereInput!]
  NOT: [TaskSubscriptionWhereInput!]
}

input TaskUpdateInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectUpdateOneWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  tags: TagUpdateManyWithoutTasksInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateManyDataInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
}

input TaskUpdateManyMutationInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
}

input TaskUpdateManyWithoutSubprojectInput {
  create: [TaskCreateWithoutSubprojectInput!]
  delete: [TaskWhereUniqueInput!]
  connect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  disconnect: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutSubprojectInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutSubprojectInput!]
  deleteMany: [TaskScalarWhereInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
}

input TaskUpdateManyWithoutTagsInput {
  create: [TaskCreateWithoutTagsInput!]
  delete: [TaskWhereUniqueInput!]
  connect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  disconnect: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutTagsInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutTagsInput!]
  deleteMany: [TaskScalarWhereInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
}

input TaskUpdateManyWithoutUserInput {
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  connect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  disconnect: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TaskScalarWhereInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  where: TaskScalarWhereInput!
  data: TaskUpdateManyDataInput!
}

input TaskUpdateOneRequiredWithoutTimelogsInput {
  create: TaskCreateWithoutTimelogsInput
  update: TaskUpdateWithoutTimelogsDataInput
  upsert: TaskUpsertWithoutTimelogsInput
  connect: TaskWhereUniqueInput
}

input TaskUpdateWithoutSubprojectDataInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  timelogs: TimelogUpdateManyWithoutTaskInput
  tags: TagUpdateManyWithoutTasksInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutTagsDataInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectUpdateOneWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutTimelogsDataInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectUpdateOneWithoutTasksInput
  tags: TagUpdateManyWithoutTasksInput
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutUserDataInput {
  name: String
  priority: String
  comments: String
  repeat: Int
  estimateTime: String
  plannedTime: String
  plannedDate: String
  finishDate: String
  deadlineDate: String
  completed: Boolean
  subproject: SubprojectUpdateOneWithoutTasksInput
  timelogs: TimelogUpdateManyWithoutTaskInput
  tags: TagUpdateManyWithoutTasksInput
}

input TaskUpdateWithWhereUniqueWithoutSubprojectInput {
  where: TaskWhereUniqueInput!
  data: TaskUpdateWithoutSubprojectDataInput!
}

input TaskUpdateWithWhereUniqueWithoutTagsInput {
  where: TaskWhereUniqueInput!
  data: TaskUpdateWithoutTagsDataInput!
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  where: TaskWhereUniqueInput!
  data: TaskUpdateWithoutUserDataInput!
}

input TaskUpsertWithoutTimelogsInput {
  update: TaskUpdateWithoutTimelogsDataInput!
  create: TaskCreateWithoutTimelogsInput!
}

input TaskUpsertWithWhereUniqueWithoutSubprojectInput {
  where: TaskWhereUniqueInput!
  update: TaskUpdateWithoutSubprojectDataInput!
  create: TaskCreateWithoutSubprojectInput!
}

input TaskUpsertWithWhereUniqueWithoutTagsInput {
  where: TaskWhereUniqueInput!
  update: TaskUpdateWithoutTagsDataInput!
  create: TaskCreateWithoutTagsInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  where: TaskWhereUniqueInput!
  update: TaskUpdateWithoutUserDataInput!
  create: TaskCreateWithoutUserInput!
}

input TaskWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  priority: String
  priority_not: String
  priority_in: [String!]
  priority_not_in: [String!]
  priority_lt: String
  priority_lte: String
  priority_gt: String
  priority_gte: String
  priority_contains: String
  priority_not_contains: String
  priority_starts_with: String
  priority_not_starts_with: String
  priority_ends_with: String
  priority_not_ends_with: String
  comments: String
  comments_not: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_lt: String
  comments_lte: String
  comments_gt: String
  comments_gte: String
  comments_contains: String
  comments_not_contains: String
  comments_starts_with: String
  comments_not_starts_with: String
  comments_ends_with: String
  comments_not_ends_with: String
  repeat: Int
  repeat_not: Int
  repeat_in: [Int!]
  repeat_not_in: [Int!]
  repeat_lt: Int
  repeat_lte: Int
  repeat_gt: Int
  repeat_gte: Int
  estimateTime: String
  estimateTime_not: String
  estimateTime_in: [String!]
  estimateTime_not_in: [String!]
  estimateTime_lt: String
  estimateTime_lte: String
  estimateTime_gt: String
  estimateTime_gte: String
  estimateTime_contains: String
  estimateTime_not_contains: String
  estimateTime_starts_with: String
  estimateTime_not_starts_with: String
  estimateTime_ends_with: String
  estimateTime_not_ends_with: String
  plannedTime: String
  plannedTime_not: String
  plannedTime_in: [String!]
  plannedTime_not_in: [String!]
  plannedTime_lt: String
  plannedTime_lte: String
  plannedTime_gt: String
  plannedTime_gte: String
  plannedTime_contains: String
  plannedTime_not_contains: String
  plannedTime_starts_with: String
  plannedTime_not_starts_with: String
  plannedTime_ends_with: String
  plannedTime_not_ends_with: String
  plannedDate: String
  plannedDate_not: String
  plannedDate_in: [String!]
  plannedDate_not_in: [String!]
  plannedDate_lt: String
  plannedDate_lte: String
  plannedDate_gt: String
  plannedDate_gte: String
  plannedDate_contains: String
  plannedDate_not_contains: String
  plannedDate_starts_with: String
  plannedDate_not_starts_with: String
  plannedDate_ends_with: String
  plannedDate_not_ends_with: String
  finishDate: String
  finishDate_not: String
  finishDate_in: [String!]
  finishDate_not_in: [String!]
  finishDate_lt: String
  finishDate_lte: String
  finishDate_gt: String
  finishDate_gte: String
  finishDate_contains: String
  finishDate_not_contains: String
  finishDate_starts_with: String
  finishDate_not_starts_with: String
  finishDate_ends_with: String
  finishDate_not_ends_with: String
  deadlineDate: String
  deadlineDate_not: String
  deadlineDate_in: [String!]
  deadlineDate_not_in: [String!]
  deadlineDate_lt: String
  deadlineDate_lte: String
  deadlineDate_gt: String
  deadlineDate_gte: String
  deadlineDate_contains: String
  deadlineDate_not_contains: String
  deadlineDate_starts_with: String
  deadlineDate_not_starts_with: String
  deadlineDate_ends_with: String
  deadlineDate_not_ends_with: String
  completed: Boolean
  completed_not: Boolean
  subproject: SubprojectWhereInput
  timelogs_every: TimelogWhereInput
  timelogs_some: TimelogWhereInput
  timelogs_none: TimelogWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  user: UserWhereInput
  AND: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  NOT: [TaskWhereInput!]
}

input TaskWhereUniqueInput {
  id: Int
}

type Timelog {
  id: Int!
  startDate: DateTime
  finishDate: DateTime
  description: String
  task: Task!
}

type TimelogConnection {
  pageInfo: PageInfo!
  edges: [TimelogEdge]!
  aggregate: AggregateTimelog!
}

input TimelogCreateInput {
  id: Int
  startDate: DateTime
  finishDate: DateTime
  description: String
  task: TaskCreateOneWithoutTimelogsInput!
}

input TimelogCreateManyWithoutTaskInput {
  create: [TimelogCreateWithoutTaskInput!]
  connect: [TimelogWhereUniqueInput!]
}

input TimelogCreateWithoutTaskInput {
  id: Int
  startDate: DateTime
  finishDate: DateTime
  description: String
}

type TimelogEdge {
  node: Timelog!
  cursor: String!
}

enum TimelogOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  finishDate_ASC
  finishDate_DESC
  description_ASC
  description_DESC
}

type TimelogPreviousValues {
  id: Int!
  startDate: DateTime
  finishDate: DateTime
  description: String
}

input TimelogScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  finishDate: DateTime
  finishDate_not: DateTime
  finishDate_in: [DateTime!]
  finishDate_not_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [TimelogScalarWhereInput!]
  OR: [TimelogScalarWhereInput!]
  NOT: [TimelogScalarWhereInput!]
}

type TimelogSubscriptionPayload {
  mutation: MutationType!
  node: Timelog
  updatedFields: [String!]
  previousValues: TimelogPreviousValues
}

input TimelogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TimelogWhereInput
  AND: [TimelogSubscriptionWhereInput!]
  OR: [TimelogSubscriptionWhereInput!]
  NOT: [TimelogSubscriptionWhereInput!]
}

input TimelogUpdateInput {
  startDate: DateTime
  finishDate: DateTime
  description: String
  task: TaskUpdateOneRequiredWithoutTimelogsInput
}

input TimelogUpdateManyDataInput {
  startDate: DateTime
  finishDate: DateTime
  description: String
}

input TimelogUpdateManyMutationInput {
  startDate: DateTime
  finishDate: DateTime
  description: String
}

input TimelogUpdateManyWithoutTaskInput {
  create: [TimelogCreateWithoutTaskInput!]
  delete: [TimelogWhereUniqueInput!]
  connect: [TimelogWhereUniqueInput!]
  set: [TimelogWhereUniqueInput!]
  disconnect: [TimelogWhereUniqueInput!]
  update: [TimelogUpdateWithWhereUniqueWithoutTaskInput!]
  upsert: [TimelogUpsertWithWhereUniqueWithoutTaskInput!]
  deleteMany: [TimelogScalarWhereInput!]
  updateMany: [TimelogUpdateManyWithWhereNestedInput!]
}

input TimelogUpdateManyWithWhereNestedInput {
  where: TimelogScalarWhereInput!
  data: TimelogUpdateManyDataInput!
}

input TimelogUpdateWithoutTaskDataInput {
  startDate: DateTime
  finishDate: DateTime
  description: String
}

input TimelogUpdateWithWhereUniqueWithoutTaskInput {
  where: TimelogWhereUniqueInput!
  data: TimelogUpdateWithoutTaskDataInput!
}

input TimelogUpsertWithWhereUniqueWithoutTaskInput {
  where: TimelogWhereUniqueInput!
  update: TimelogUpdateWithoutTaskDataInput!
  create: TimelogCreateWithoutTaskInput!
}

input TimelogWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  finishDate: DateTime
  finishDate_not: DateTime
  finishDate_in: [DateTime!]
  finishDate_not_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  task: TaskWhereInput
  AND: [TimelogWhereInput!]
  OR: [TimelogWhereInput!]
  NOT: [TimelogWhereInput!]
}

input TimelogWhereUniqueInput {
  id: Int
}

type User {
  id: Int!
  email: String!
  password: String!
  tasks(where: TaskWhereInput, orderBy: TaskOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Task!]
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: Int
  email: String!
  password: String!
  tasks: TaskCreateManyWithoutUserInput
  projects: ProjectCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
}

input UserCreateOneWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTasksInput {
  create: UserCreateWithoutTasksInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutProjectsInput {
  id: Int
  email: String!
  password: String!
  tasks: TaskCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
}

input UserCreateWithoutTagsInput {
  id: Int
  email: String!
  password: String!
  tasks: TaskCreateManyWithoutUserInput
  projects: ProjectCreateManyWithoutUserInput
}

input UserCreateWithoutTasksInput {
  id: Int
  email: String!
  password: String!
  projects: ProjectCreateManyWithoutUserInput
  tags: TagCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: Int!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  tasks: TaskUpdateManyWithoutUserInput
  projects: ProjectUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
}

input UserUpdateOneWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput
  update: UserUpdateWithoutProjectsDataInput
  upsert: UserUpsertWithoutProjectsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutTagsInput {
  create: UserCreateWithoutTagsInput
  update: UserUpdateWithoutTagsDataInput
  upsert: UserUpsertWithoutTagsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutTasksInput {
  create: UserCreateWithoutTasksInput
  update: UserUpdateWithoutTasksDataInput
  upsert: UserUpsertWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutProjectsDataInput {
  email: String
  password: String
  tasks: TaskUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
}

input UserUpdateWithoutTagsDataInput {
  email: String
  password: String
  tasks: TaskUpdateManyWithoutUserInput
  projects: ProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutTasksDataInput {
  email: String
  password: String
  projects: ProjectUpdateManyWithoutUserInput
  tags: TagUpdateManyWithoutUserInput
}

input UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput!
  create: UserCreateWithoutProjectsInput!
}

input UserUpsertWithoutTagsInput {
  update: UserUpdateWithoutTagsDataInput!
  create: UserCreateWithoutTagsInput!
}

input UserUpsertWithoutTasksInput {
  update: UserUpdateWithoutTasksDataInput!
  create: UserCreateWithoutTasksInput!
}

input UserWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  tasks_every: TaskWhereInput
  tasks_some: TaskWhereInput
  tasks_none: TaskWhereInput
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
  email: String
}
`